var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = DifferentiationInterface","category":"page"},{"location":"#DifferentiationInterface","page":"Home","title":"DifferentiationInterface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DifferentiationInterface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is an interface to various autodiff backends for differentiating functions of the form f(x) = y, where x and y are either numbers or arrays.","category":"page"},{"location":"#Public","page":"Home","title":"Public","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [DifferentiationInterface]\nPrivate = false","category":"page"},{"location":"#DifferentiationInterface.DifferentiationInterface","page":"Home","title":"DifferentiationInterface.DifferentiationInterface","text":"DifferentiationInterface\n\nAn experimental redesign for AbstractDifferentiation.jl.\n\nExports\n\nChainRulesForwardBackend\nChainRulesReverseBackend\nEnzymeForwardBackend\nEnzymeReverseBackend\nFiniteDiffBackend\nForwardDiffBackend\nReverseDiffBackend\npullback!\npushforward!\nvalue_and_pullback!\nvalue_and_pushforward!\n\n\n\n\n\n","category":"module"},{"location":"#DifferentiationInterface.ChainRulesForwardBackend","page":"Home","title":"DifferentiationInterface.ChainRulesForwardBackend","text":"ChainRulesForwardBackend{RC}\n\nPerforms autodiff with forward-mode AD packages based on ChainRulesCore.jl, like Diffractor.jl.\n\nThis must be constructed with an appropriate RuleConfig instance.\n\nusing Diffractor, DifferentiationInterface\nbackend = ChainRulesForwardBackend(Diffractor.DiffractorRuleConfig())\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiationInterface.ChainRulesReverseBackend","page":"Home","title":"DifferentiationInterface.ChainRulesReverseBackend","text":"ChainRulesReverseBackend{RC}\n\nPerforms autodiff with reverse-mode AD packages based on ChainRulesCore.jl, like Zygote.jl.\n\nThis must be constructed with an appropriate RuleConfig instance:\n\nusing Zygote, DifferentiationInterface\nbackend = ChainRulesReverseBackend(Zygote.ZygoteRuleConfig())\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiationInterface.EnzymeForwardBackend","page":"Home","title":"DifferentiationInterface.EnzymeForwardBackend","text":"EnzymeForwardBackend\n\nPerforms forward-mode autodiff with Enzyme.jl.\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiationInterface.EnzymeReverseBackend","page":"Home","title":"DifferentiationInterface.EnzymeReverseBackend","text":"EnzymeReverseBackend\n\nPerforms reverse-mode autodiff with Enzyme.jl.\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiationInterface.FiniteDiffBackend","page":"Home","title":"DifferentiationInterface.FiniteDiffBackend","text":"FiniteDiffBackend\n\nPerforms autodiff with FiniteDiff.jl.\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiationInterface.ForwardDiffBackend","page":"Home","title":"DifferentiationInterface.ForwardDiffBackend","text":"ForwardDiffBackend\n\nPerforms autodiff with ForwardDiff.jl.\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiationInterface.ReverseDiffBackend","page":"Home","title":"DifferentiationInterface.ReverseDiffBackend","text":"ReverseDiffBackend\n\nPerforms autodiff with ReverseDiff.jl.\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiationInterface.pullback!-NTuple{6, Any}","page":"Home","title":"DifferentiationInterface.pullback!","text":"pullback!(dx, backend, f, x, dy[, stuff])\n\nCompute a vector-Jacobian product inside dx and return it.\n\nSee value_and_pullback!.\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiationInterface.pushforward!-NTuple{6, Any}","page":"Home","title":"DifferentiationInterface.pushforward!","text":"pushforward!(dy, backend, f, x, dx[, stuff])\n\nCompute a Jacobian-vector product inside dy and return it.\n\nSee value_and_pushforward!.\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiationInterface.value_and_pullback!","page":"Home","title":"DifferentiationInterface.value_and_pullback!","text":"value_and_pullback!(dx, backend, f, x, dy[, stuff]) -> (y, dx)\n\nCompute a vector-Jacobian product inside dx and return it and the primal output.\n\nArguments\n\ny: primal output\ndx: tangent, might be modified\nbackend: reverse-mode autodiff backend\nf: function x -> y to differentiate\nx: argument\ndy: cotangent\nstuff: optional backend-specific storage (cache, config), might be modified\n\n\n\n\n\n","category":"function"},{"location":"#DifferentiationInterface.value_and_pushforward!","page":"Home","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(dy, backend, f, x, dx[, stuff]) -> (y, dy)\n\nCompute a Jacobian-vector product inside dy and return it and the primal output.\n\nArguments\n\ny: primal output\ndy: cotangent, might be modified\nbackend: forward-mode autodiff backend\nf: function x -> y to differentiate\nx: argument\ndx: tangent\nstuff: optional backend-specific storage (cache, config), might be modified\n\n\n\n\n\n","category":"function"},{"location":"#Internals","page":"Home","title":"Internals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [DifferentiationInterface]\nPublic = false","category":"page"},{"location":"#Math","page":"Home","title":"Math","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Some implementation reminders:","category":"page"},{"location":"","page":"Home","title":"Home","text":" pushforward pullback\nscalar -> scalar derivative multiplied by the tangent derivative multiplied by the cotangent\nscalar -> vector derivative vector multiplied componentwise by the tangent vector dot product between the derivative vector and the cotangent vector\nvector -> scalar dot product between the gradient vector and the tangent vector gradient vector multiplied componentwise by the cotangent\nvector -> vector Jacobian matrix multiplied by the tangent vector transposed Jacobian matrix multiplied by the cotangent vector","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
