var documenterSearchIndex = {"docs":
[{"location":"interface/","page":"Interface","title":"Interface","text":"CurrentModule = DifferentiationInterface\nCollapsedDocStrings = true","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"DifferentiationInterface","category":"page"},{"location":"interface/#DifferentiationInterface.DifferentiationInterface","page":"Interface","title":"DifferentiationInterface.DifferentiationInterface","text":"DifferentiationInterface\n\nAn interface to various automatic differentiation backends in Julia.\n\nExports\n\nAbstractBackend\nAbstractForwardBackend\nAbstractReverseBackend\nChainRulesForwardBackend\nChainRulesReverseBackend\nEnzymeForwardBackend\nEnzymeReverseBackend\nFiniteDiffBackend\nForwardDiffBackend\nPolyesterForwardDiffBackend\nReverseDiffBackend\nZygoteBackend\nautodiff_mode\nhandles_input_type\nhandles_output_type\nhandles_types\nis_custom\nvalue_and_derivative\nvalue_and_gradient\nvalue_and_gradient!\nvalue_and_jacobian\nvalue_and_jacobian!\nvalue_and_multiderivative\nvalue_and_multiderivative!\nvalue_and_pullback\nvalue_and_pullback!\nvalue_and_pushforward\nvalue_and_pushforward!\n\n\n\n\n\n","category":"module"},{"location":"interface/#Utilities","page":"Interface","title":"Utilities","text":"","category":"section"},{"location":"interface/#Scalar-to-scalar","page":"Interface","title":"Scalar to scalar","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"scalar_scalar.jl\"]","category":"page"},{"location":"interface/#DifferentiationInterface.value_and_derivative","page":"Interface","title":"DifferentiationInterface.value_and_derivative","text":"value_and_derivative(backend, f, x) -> (y, der)\n\nCompute the primal value y = f(x) and the derivative der = f'(x) of a scalar-to-scalar function.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Scalar-to-array","page":"Interface","title":"Scalar to array","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"scalar_array.jl\"]","category":"page"},{"location":"interface/#DifferentiationInterface.value_and_multiderivative!","page":"Interface","title":"DifferentiationInterface.value_and_multiderivative!","text":"value_and_multiderivative!(multider, backend, f, x) -> (y, multider)\n\nCompute the primal value y = f(x) and the (array-valued) derivative multider = f'(x) of a scalar-to-array function, overwriting multider if possible.\n\n\n\n\n\n","category":"function"},{"location":"interface/#DifferentiationInterface.value_and_multiderivative-Tuple{AbstractBackend, Any, Number}","page":"Interface","title":"DifferentiationInterface.value_and_multiderivative","text":"value_and_multiderivative(backend, f, x) -> (y, multider)\n\nCompute the primal value y = f(x) and the (array-valued) derivative multider = f'(x) of a scalar-to-array function.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Array-to-scalar","page":"Interface","title":"Array to scalar","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"array_scalar.jl\"]","category":"page"},{"location":"interface/#DifferentiationInterface.value_and_gradient!","page":"Interface","title":"DifferentiationInterface.value_and_gradient!","text":"value_and_gradient!(grad, backend, f, x) -> (y, grad)\n\nCompute the primal value y = f(x) and the gradient grad = ∇f(x) of an array-to-scalar function, overwriting grad if possible.\n\n\n\n\n\n","category":"function"},{"location":"interface/#DifferentiationInterface.value_and_gradient-Tuple{AbstractBackend, Any, AbstractArray}","page":"Interface","title":"DifferentiationInterface.value_and_gradient","text":"value_and_gradient(backend, f, x) -> (y, grad)\n\nCompute the primal value y = f(x) and the gradient grad = ∇f(x) of an array-to-scalar function.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Array-to-array","page":"Interface","title":"Array to array","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"array_array.jl\"]","category":"page"},{"location":"interface/#DifferentiationInterface.value_and_jacobian!-Tuple{AbstractMatrix, AbstractBackend, Any, AbstractArray}","page":"Interface","title":"DifferentiationInterface.value_and_jacobian!","text":"value_and_jacobian!(jac, backend, f, x) -> (y, jac)\n\nCompute the primal value y = f(x) and the Jacobian matrix jac = ∂f(x) of an array-to-array function, overwriting jac if possible.\n\nNotes\n\nRegardless of the shape of x and y, if x has length n and y has length m, then jac is expected to be a m × n matrix. This function acts as if the input and output had been flattened with vec. \n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.value_and_jacobian-Tuple{AbstractBackend, Any, AbstractArray}","page":"Interface","title":"DifferentiationInterface.value_and_jacobian","text":"value_and_jacobian(backend, f, x) -> (y, jac)\n\nCompute the primal value y = f(x) and the Jacobian matrix jac = ∂f(x) of an array-to-array function.\n\nNotes\n\nRegardless of the shape of x and y, if x has length n and y has length m, then jac is expected to be a m × n matrix. This function acts as if the input and output had been flattened with vec. \n\n\n\n\n\n","category":"method"},{"location":"interface/#Primitives","page":"Interface","title":"Primitives","text":"","category":"section"},{"location":"interface/#Pushforward","page":"Interface","title":"Pushforward","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"pushforward.jl\"]","category":"page"},{"location":"interface/#DifferentiationInterface.value_and_pushforward!-Tuple{Any, AbstractForwardBackend, Any, Any, Any}","page":"Interface","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(dy, backend::AbstractForwardBackend, f, x, dx) -> (y, dy)\n\nCompute the primal value y = f(x) and the Jacobian-vector product dy = ∂f(x) * dx, overwriting dy if possible.\n\ninfo: Interface requirement\nThis is the only required implementation for an AbstractForwardBackend.\n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.value_and_pushforward-Tuple{AbstractForwardBackend, Any, Any, Any}","page":"Interface","title":"DifferentiationInterface.value_and_pushforward","text":"value_and_pushforward(backend::AbstractForwardBackend, f, x, dx) -> (y, dy)\n\nCompute the primal value y = f(x) and the Jacobian-vector product dy = ∂f(x) * dx.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Pullback","page":"Interface","title":"Pullback","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"pullback.jl\"]","category":"page"},{"location":"interface/#DifferentiationInterface.value_and_pullback!-Tuple{Any, AbstractReverseBackend, Any, Any, Any}","page":"Interface","title":"DifferentiationInterface.value_and_pullback!","text":"value_and_pullback!(dx, backend::AbstractReverseBackend, f, x, dy) -> (y, dx)\n\nCompute the primal value y = f(x) and the vector-Jacobian product dx = ∂f(x)' * dy, overwriting dx if possible.\n\ninfo: Interface requirement\nThis is the only required implementation for an AbstractReverseBackend.\n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.value_and_pullback-Tuple{AbstractReverseBackend, Any, Any, Any}","page":"Interface","title":"DifferentiationInterface.value_and_pullback","text":"value_and_pullback(backend::AbstractReverseBackend, f, x, dy) -> (y, dx)\n\nCompute the primal value y = f(x) and the vector-Jacobian product dx = ∂f(x)' * dy.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Abstract-backends","page":"Interface","title":"Abstract backends","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"backends_abstract.jl\"]","category":"page"},{"location":"interface/#DifferentiationInterface.AbstractBackend","page":"Interface","title":"DifferentiationInterface.AbstractBackend","text":"AbstractBackend\n\nAbstract type pointing to the AD package chosen by the user, which is called a \"backend\".\n\nCustom\n\nWhen we say that a backend is \"custom\", it describes how the utilities (derivative, multiderivative, gradient and jacobian) are implemented:\n\nCustom backends use specific routines defined in their package whenever they exist\nNon-custom backends use fallbacks defined in DifferentiationInterface.jl, which end up calling the pushforward or pullback\n\n\n\n\n\n","category":"type"},{"location":"interface/#DifferentiationInterface.AbstractForwardBackend","page":"Interface","title":"DifferentiationInterface.AbstractForwardBackend","text":"AbstractForwardBackend <: AbstractBackend\n\nAbstract subtype of AbstractBackend for forward mode AD packages.\n\n\n\n\n\n","category":"type"},{"location":"interface/#DifferentiationInterface.AbstractReverseBackend","page":"Interface","title":"DifferentiationInterface.AbstractReverseBackend","text":"AbstractReverseBackend <: AbstractBackend\n\nAbstract subtype of AbstractBackend for reverse mode AD packages.\n\n\n\n\n\n","category":"type"},{"location":"interface/#DifferentiationInterface.autodiff_mode-Tuple{AbstractForwardBackend}","page":"Interface","title":"DifferentiationInterface.autodiff_mode","text":"autodiff_mode(backend)\n\nReturn either :forward or :reverse depending on the mode of backend.\n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.handles_input_type-Tuple{AbstractBackend, Type{<:Number}}","page":"Interface","title":"DifferentiationInterface.handles_input_type","text":"handles_input_type(backend, ::Type{X})\n\nCheck if backend can differentiate functions with input type X.\n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.handles_output_type-Tuple{AbstractBackend, Type{<:Number}}","page":"Interface","title":"DifferentiationInterface.handles_output_type","text":"handles_output_type(backend, ::Type{Y})\n\nCheck if backend can differentiate functions with output type Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.handles_types-Union{Tuple{Y}, Tuple{X}, Tuple{AbstractBackend, Type{X}, Type{Y}}} where {X, Y}","page":"Interface","title":"DifferentiationInterface.handles_types","text":"handles_types(backend, ::Type{X}, ::Type{Y})\n\nCheck if backend can differentiate functions with input type X and output type Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.is_custom-Union{Tuple{AbstractBackend{custom}}, Tuple{custom}} where custom","page":"Interface","title":"DifferentiationInterface.is_custom","text":"is_custom(backend)\n\nReturn a boolean custom that describes how utilities (derivative, multiderivative, gradient and jacobian) are implemented.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Internals","page":"Interface","title":"Internals","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"utils.jl\"]","category":"page"},{"location":"interface/#DifferentiationInterface.basisarray-Tuple{AbstractBackend, AbstractArray, Any}","page":"Interface","title":"DifferentiationInterface.basisarray","text":"basisarray(backend, a::AbstractArray, i::CartesianIndex)\n\nConstruct the i-th stardard basis array in the vector space of a with element type eltype(a).\n\nNote\n\nIf an AD backend benefits from a more specialized basis array implementation, this function can be extended on the backend type.\n\n\n\n\n\n","category":"method"},{"location":"backends/","page":"Backends","title":"Backends","text":"CollapsedDocStrings = true","category":"page"},{"location":"backends/#Backends","page":"Backends","title":"Backends","text":"","category":"section"},{"location":"backends/#ChainRulesCore","page":"Backends","title":"ChainRulesCore","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"ChainRulesForwardBackend\nChainRulesReverseBackend","category":"page"},{"location":"backends/#DifferentiationInterface.ChainRulesForwardBackend","page":"Backends","title":"DifferentiationInterface.ChainRulesForwardBackend","text":"ChainRulesForwardBackend <: AbstractForwardBackend\n\nEnables the use of forward mode AD packages based on ChainRulesCore.jl.\n\n\n\n\n\n","category":"type"},{"location":"backends/#DifferentiationInterface.ChainRulesReverseBackend","page":"Backends","title":"DifferentiationInterface.ChainRulesReverseBackend","text":"ChainRulesReverseBackend <: AbstractReverseBackend\n\nEnables the use of reverse mode AD packages based on ChainRulesCore.jl.\n\n\n\n\n\n","category":"type"},{"location":"backends/","page":"Backends","title":"Backends","text":"Modules = [ChainRulesCoreExt]","category":"page"},{"location":"backends/#DifferentiationInterface.ChainRulesForwardBackend-Tuple{ChainRulesCore.RuleConfig{>:ChainRulesCore.HasForwardsMode}}","page":"Backends","title":"DifferentiationInterface.ChainRulesForwardBackend","text":"ChainRulesForwardBackend(rc::RuleConfig; custom=true)\n\nConstruct a ChainRulesForwardBackend from a RuleConfig object that HasForwardsMode.\n\nExample\n\nusing Diffractor, DifferentiationInterface\nbackend = ChainRulesForwardBackend(Diffractor.DiffractorRuleConfig())\n\n\n\n\n\n","category":"method"},{"location":"backends/#DifferentiationInterface.ChainRulesReverseBackend-Tuple{ChainRulesCore.RuleConfig{>:ChainRulesCore.HasReverseMode}}","page":"Backends","title":"DifferentiationInterface.ChainRulesReverseBackend","text":"ChainRulesReverseBackend(rc::RuleConfig; custom=true)\n\nConstruct a ChainRulesReverseBackend from a RuleConfig object that HasReverseMode.\n\nExample\n\nusing Zygote, DifferentiationInterface\nbackend = ChainRulesReverseBackend(Zygote.ZygoteRuleConfig())\n\n\n\n\n\n","category":"method"},{"location":"backends/#Enzyme","page":"Backends","title":"Enzyme","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"EnzymeForwardBackend\nEnzymeReverseBackend","category":"page"},{"location":"backends/#DifferentiationInterface.EnzymeForwardBackend","page":"Backends","title":"DifferentiationInterface.EnzymeForwardBackend","text":"EnzymeForwardBackend <: AbstractForwardBackend\n\nEnables the use of Enzyme.jl in forward mode.\n\n\n\n\n\n","category":"type"},{"location":"backends/#DifferentiationInterface.EnzymeReverseBackend","page":"Backends","title":"DifferentiationInterface.EnzymeReverseBackend","text":"EnzymeReverseBackend <: AbstractReverseBackend\n\nEnables the use of Enzyme.jl in reverse mode.\n\nwarning: Warning\nThis backend only works for scalar output.\n\n\n\n\n\n","category":"type"},{"location":"backends/","page":"Backends","title":"Backends","text":"Modules = [EnzymeExt]","category":"page"},{"location":"backends/#DifferentiationInterface.EnzymeForwardBackend-Tuple{}","page":"Backends","title":"DifferentiationInterface.EnzymeForwardBackend","text":"EnzymeForwardBackend(; custom=true)\n\nConstruct a EnzymeForwardBackend.\n\n\n\n\n\n","category":"method"},{"location":"backends/#DifferentiationInterface.EnzymeReverseBackend-Tuple{}","page":"Backends","title":"DifferentiationInterface.EnzymeReverseBackend","text":"EnzymeReverseBackend(; custom=true)\n\nConstruct a EnzymeReverseBackend.\n\n\n\n\n\n","category":"method"},{"location":"backends/#FiniteDiff","page":"Backends","title":"FiniteDiff","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"FiniteDiffBackend","category":"page"},{"location":"backends/#DifferentiationInterface.FiniteDiffBackend","page":"Backends","title":"DifferentiationInterface.FiniteDiffBackend","text":"FiniteDiffBackend <: AbstractForwardBackend\n\nEnables the use of FiniteDiff.jl.\n\n\n\n\n\n","category":"type"},{"location":"backends/","page":"Backends","title":"Backends","text":"Modules = [FiniteDiffExt]","category":"page"},{"location":"backends/#DifferentiationInterface.FiniteDiffBackend-Union{Tuple{}, Tuple{Type{fdtype}}, Tuple{fdtype}} where fdtype","page":"Backends","title":"DifferentiationInterface.FiniteDiffBackend","text":"FiniteDiffBackend(::Type{fdtype}=Val{:central}; custom=true)\n\nConstruct a FiniteDiffBackend with any finite difference type fdtype (Val{:forward} or Val{:central}).\n\n\n\n\n\n","category":"method"},{"location":"backends/#ForwardDiff","page":"Backends","title":"ForwardDiff","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"ForwardDiffBackend","category":"page"},{"location":"backends/#DifferentiationInterface.ForwardDiffBackend","page":"Backends","title":"DifferentiationInterface.ForwardDiffBackend","text":"ForwardDiffBackend <: AbstractForwardBackend\n\nEnables the use of ForwardDiff.jl.\n\n\n\n\n\n","category":"type"},{"location":"backends/","page":"Backends","title":"Backends","text":"Modules = [ForwardDiffExt]","category":"page"},{"location":"backends/#DifferentiationInterface.ForwardDiffBackend-Tuple{}","page":"Backends","title":"DifferentiationInterface.ForwardDiffBackend","text":"ForwardDiffBackend(; custom=true)\n\nConstruct a ForwardDiffBackend.\n\n\n\n\n\n","category":"method"},{"location":"backends/#PolyesterForwardDiff","page":"Backends","title":"PolyesterForwardDiff","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"PolyesterForwardDiffBackend","category":"page"},{"location":"backends/#DifferentiationInterface.PolyesterForwardDiffBackend","page":"Backends","title":"DifferentiationInterface.PolyesterForwardDiffBackend","text":"PolyesterForwardDiffBackend <: AbstractForwardBackend\n\nEnables the use of PolyesterForwardDiff.jl, falling back on ForwardDiff.jl if needed.\n\nwarning: Warning\nThis backend only works when the arrays are vectors.\n\n\n\n\n\n","category":"type"},{"location":"backends/","page":"Backends","title":"Backends","text":"Modules = [PolyesterForwardDiffExt]","category":"page"},{"location":"backends/#DifferentiationInterface.PolyesterForwardDiffBackend-Tuple{Integer}","page":"Backends","title":"DifferentiationInterface.PolyesterForwardDiffBackend","text":"PolyesterForwardDiffBackend(C; custom=true)\n\nConstruct a PolyesterForwardDiffBackend with chunk size C.\n\n\n\n\n\n","category":"method"},{"location":"backends/#ReverseDiff","page":"Backends","title":"ReverseDiff","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"ReverseDiffBackend","category":"page"},{"location":"backends/#DifferentiationInterface.ReverseDiffBackend","page":"Backends","title":"DifferentiationInterface.ReverseDiffBackend","text":"ReverseDiffBackend <: AbstractReverseBackend\n\nPerforms autodiff with ReverseDiff.jl.\n\nwarning: Warning\nThis backend only works for array input.\n\n\n\n\n\n","category":"type"},{"location":"backends/","page":"Backends","title":"Backends","text":"Modules = [ReverseDiffExt]","category":"page"},{"location":"backends/#DifferentiationInterface.ReverseDiffBackend-Tuple{}","page":"Backends","title":"DifferentiationInterface.ReverseDiffBackend","text":"ReverseDiffBackend(; custom)\n\nConstruct a ReverseDiffBackend.\n\n\n\n\n\n","category":"method"},{"location":"backends/#Zygote","page":"Backends","title":"Zygote","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"Modules = [ZygoteExt]","category":"page"},{"location":"backends/#DifferentiationInterface.ZygoteBackend-Tuple{}","page":"Backends","title":"DifferentiationInterface.ZygoteBackend","text":"ZygoteBackend(; custom=true)\n\nEnables the use of Zygote.jl by constructing a ChainRulesReverseBackend from ZygoteRuleConfig().\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"https://github.com/gdalle/DifferentiationInterface.jl/blob/main/README.md\"","category":"page"},{"location":"#DifferentiationInterface","page":"Home","title":"DifferentiationInterface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"An interface to various automatic differentiation backends in Julia.","category":"page"},{"location":"#Goal","page":"Home","title":"Goal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a backend-agnostic syntax to differentiate functions f(x) = y, where x and y are either numbers or abstract arrays.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It started out as an experimental redesign for AbstractDifferentiation.jl.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using DifferentiationInterface, Enzyme\n\njulia> backend = EnzymeReverseBackend();\n\njulia> f(x) = sum(abs2, x);\n\njulia> value_and_gradient(backend, f, [1., 2., 3.])\n(14.0, [2.0, 4.0, 6.0])","category":"page"},{"location":"#Design","page":"Home","title":"Design","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each backend must implement only one primitive:","category":"page"},{"location":"","page":"Home","title":"Home","text":"forward mode: the pushforward, computing a Jacobian-vector product\nreverse mode: the pullback, computing a vector-Jacobian product","category":"page"},{"location":"","page":"Home","title":"Home","text":"From these primitives, several utilities are defined, depending on the type of the input and output:","category":"page"},{"location":"","page":"Home","title":"Home","text":" scalar output array output\nscalar input derivative multiderivative\narray input gradient jacobian","category":"page"},{"location":"#Supported-backends","page":"Home","title":"Supported backends","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Forward mode:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ForwardDiff.jl\nEnzyme.jl\nChainRulesCore.jl\nFiniteDiff.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Reverse mode:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ChainRulesCore.jl\nZygote.jl\nReverseDiff.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Experimental:","category":"page"},{"location":"","page":"Home","title":"Home","text":"PolyesterForwardDiff.jl\nDiffractor.jl (currently broken due to #277)","category":"page"}]
}
