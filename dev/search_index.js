var documenterSearchIndex = {"docs":
[{"location":"interface/","page":"Interface","title":"Interface","text":"CurrentModule = DifferentiationInterface\nCollapsedDocStrings = true","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"DifferentiationInterface","category":"page"},{"location":"interface/#DifferentiationInterface.DifferentiationInterface","page":"Interface","title":"DifferentiationInterface.DifferentiationInterface","text":"DifferentiationInterface\n\nAn interface to various automatic differentiation backends in Julia.\n\nExports\n\nAutoChainRules\nAutoDiffractor\nderivative\ngradient\ngradient!\nhandles_input_type\nhandles_output_type\nhandles_types\njacobian\njacobian!\nmultiderivative\nmultiderivative!\npullback\npullback!\npushforward\npushforward!\nvalue_and_derivative\nvalue_and_gradient\nvalue_and_gradient!\nvalue_and_jacobian\nvalue_and_jacobian!\nvalue_and_multiderivative\nvalue_and_multiderivative!\nvalue_and_pullback\nvalue_and_pullback!\nvalue_and_pushforward\nvalue_and_pushforward!\n\n\n\n\n\n","category":"module"},{"location":"interface/#Utilities","page":"Interface","title":"Utilities","text":"","category":"section"},{"location":"interface/#Scalar-to-scalar","page":"Interface","title":"Scalar to scalar","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"scalar_scalar.jl\"]","category":"page"},{"location":"interface/#DifferentiationInterface.derivative-Tuple{ADTypes.AbstractADType, Any, Number, Vararg{Any}}","page":"Interface","title":"DifferentiationInterface.derivative","text":"derivative(backend, f, x, [extras]) -> der\n\nCompute the derivative der = f'(x) of a scalar-to-scalar function.\n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.value_and_derivative","page":"Interface","title":"DifferentiationInterface.value_and_derivative","text":"value_and_derivative(backend, f, x, [extras]) -> (y, der)\n\nCompute the primal value y = f(x) and the derivative der = f'(x) of a scalar-to-scalar function.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Scalar-to-array","page":"Interface","title":"Scalar to array","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"scalar_array.jl\"]","category":"page"},{"location":"interface/#DifferentiationInterface.multiderivative!-Tuple{AbstractArray, ADTypes.AbstractADType, Any, Number, Vararg{Any}}","page":"Interface","title":"DifferentiationInterface.multiderivative!","text":"multiderivative!(multider, backend, f, x, [extras]) -> multider\n\nCompute the (array-valued) derivative multider = f'(x) of a scalar-to-array function, overwriting multider if possible.\n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.multiderivative-Tuple{ADTypes.AbstractADType, Any, Number, Vararg{Any}}","page":"Interface","title":"DifferentiationInterface.multiderivative","text":"multiderivative(backend, f, x, [extras]) -> multider\n\nCompute the (array-valued) derivative multider = f'(x) of a scalar-to-array function.\n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.value_and_multiderivative!","page":"Interface","title":"DifferentiationInterface.value_and_multiderivative!","text":"value_and_multiderivative!(multider, backend, f, x, [extras]) -> (y, multider)\n\nCompute the primal value y = f(x) and the (array-valued) derivative multider = f'(x) of a scalar-to-array function, overwriting multider if possible.\n\n\n\n\n\n","category":"function"},{"location":"interface/#DifferentiationInterface.value_and_multiderivative-Tuple{ADTypes.AbstractADType, Any, Number, Vararg{Any}}","page":"Interface","title":"DifferentiationInterface.value_and_multiderivative","text":"value_and_multiderivative(backend, f, x, [extras]) -> (y, multider)\n\nCompute the primal value y = f(x) and the (array-valued) derivative multider = f'(x) of a scalar-to-array function.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Array-to-scalar","page":"Interface","title":"Array to scalar","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"array_scalar.jl\"]","category":"page"},{"location":"interface/#DifferentiationInterface.gradient!-Tuple{AbstractArray, ADTypes.AbstractADType, Any, AbstractArray, Vararg{Any}}","page":"Interface","title":"DifferentiationInterface.gradient!","text":"gradient!(grad, backend, f, x, [extras]) -> grad\n\nCompute the gradient grad = ∇f(x) of an array-to-scalar function, overwriting grad if possible.\n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.gradient-Tuple{ADTypes.AbstractADType, Any, AbstractArray, Vararg{Any}}","page":"Interface","title":"DifferentiationInterface.gradient","text":"gradient(backend, f, x, [extras]) -> grad\n\nCompute the gradient grad = ∇f(x) of an array-to-scalar function.\n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.value_and_gradient!","page":"Interface","title":"DifferentiationInterface.value_and_gradient!","text":"value_and_gradient!(grad, backend, f, x, [extras]) -> (y, grad)\n\nCompute the primal value y = f(x) and the gradient grad = ∇f(x) of an array-to-scalar function, overwriting grad if possible.\n\n\n\n\n\n","category":"function"},{"location":"interface/#DifferentiationInterface.value_and_gradient-Tuple{ADTypes.AbstractADType, Any, AbstractArray, Vararg{Any}}","page":"Interface","title":"DifferentiationInterface.value_and_gradient","text":"value_and_gradient(backend, f, x, [extras]) -> (y, grad)\n\nCompute the primal value y = f(x) and the gradient grad = ∇f(x) of an array-to-scalar function.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Array-to-array","page":"Interface","title":"Array to array","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"array_array.jl\"]","category":"page"},{"location":"interface/#DifferentiationInterface.jacobian!-Tuple{AbstractMatrix, ADTypes.AbstractADType, Any, AbstractArray, Vararg{Any}}","page":"Interface","title":"DifferentiationInterface.jacobian!","text":"jacobian!(jac, backend, f, x, [extras]) -> jac\n\nCompute the Jacobian matrix jac = ∂f(x) of an array-to-array function, overwriting jac if possible.\n\nNotes\n\nRegardless of the shape of x and y, if x has length n and y has length m, then jac is expected to be a m × n matrix. This function acts as if the input and output had been flattened with vec. \n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.jacobian-Tuple{ADTypes.AbstractADType, Any, AbstractArray, Vararg{Any}}","page":"Interface","title":"DifferentiationInterface.jacobian","text":"jacobian(backend, f, x, [extras]) -> jac\n\nCompute the Jacobian matrix jac = ∂f(x) of an array-to-array function.\n\nNotes\n\nRegardless of the shape of x and y, if x has length n and y has length m, then jac is expected to be a m × n matrix. This function acts as if the input and output had been flattened with vec. \n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.value_and_jacobian!","page":"Interface","title":"DifferentiationInterface.value_and_jacobian!","text":"value_and_jacobian!(jac, backend, f, x, [extras]) -> (y, jac)\n\nCompute the primal value y = f(x) and the Jacobian matrix jac = ∂f(x) of an array-to-array function, overwriting jac if possible.\n\nNotes\n\nRegardless of the shape of x and y, if x has length n and y has length m, then jac is expected to be a m × n matrix. This function acts as if the input and output had been flattened with vec. \n\n\n\n\n\n","category":"function"},{"location":"interface/#DifferentiationInterface.value_and_jacobian-Tuple{ADTypes.AbstractADType, Any, AbstractArray, Vararg{Any}}","page":"Interface","title":"DifferentiationInterface.value_and_jacobian","text":"value_and_jacobian(backend, f, x, [extras]) -> (y, jac)\n\nCompute the primal value y = f(x) and the Jacobian matrix jac = ∂f(x) of an array-to-array function.\n\nNotes\n\nRegardless of the shape of x and y, if x has length n and y has length m, then jac is expected to be a m × n matrix. This function acts as if the input and output had been flattened with vec. \n\n\n\n\n\n","category":"method"},{"location":"interface/#Primitives","page":"Interface","title":"Primitives","text":"","category":"section"},{"location":"interface/#Pushforward","page":"Interface","title":"Pushforward","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"pushforward.jl\"]","category":"page"},{"location":"interface/#DifferentiationInterface.pushforward","page":"Interface","title":"DifferentiationInterface.pushforward","text":"pushforward(backend, f, x, dx, [extras]) -> dy\n\nCompute the Jacobian-vector product dy = ∂f(x) * dx.\n\n\n\n\n\n","category":"function"},{"location":"interface/#DifferentiationInterface.pushforward!","page":"Interface","title":"DifferentiationInterface.pushforward!","text":"pushforward!(dy, backend, f, x, dx, [extras]) -> dy\n\nCompute the Jacobian-vector product dy = ∂f(x) * dx, overwriting dy if possible.\n\n\n\n\n\n","category":"function"},{"location":"interface/#DifferentiationInterface.value_and_pushforward","page":"Interface","title":"DifferentiationInterface.value_and_pushforward","text":"value_and_pushforward(backend, f, x, dx, [extras]) -> (y, dy)\n\nCompute the primal value y = f(x) and the Jacobian-vector product dy = ∂f(x) * dx.\n\n\n\n\n\n","category":"function"},{"location":"interface/#DifferentiationInterface.value_and_pushforward!","page":"Interface","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(dy, backend, f, x, dx, [extras]) -> (y, dy)\n\nCompute the primal value y = f(x) and the Jacobian-vector product dy = ∂f(x) * dx, overwriting dy if possible.\n\ninfo: Interface requirement\nThis is the only required implementation for a forward mode backend.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Pullback","page":"Interface","title":"Pullback","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"pullback.jl\"]","category":"page"},{"location":"interface/#DifferentiationInterface.pullback","page":"Interface","title":"DifferentiationInterface.pullback","text":"pullback(backend, f, x, dy, [extras]) -> dx\n\nCompute the vector-Jacobian product dx = ∂f(x)' * dy.\n\n\n\n\n\n","category":"function"},{"location":"interface/#DifferentiationInterface.pullback!","page":"Interface","title":"DifferentiationInterface.pullback!","text":"pullback!(dx, backend, f, x, dy, [extras]) -> dx\n\nCompute the vector-Jacobian product dx = ∂f(x)' * dy, overwriting dx if possible.\n\n\n\n\n\n","category":"function"},{"location":"interface/#DifferentiationInterface.value_and_pullback","page":"Interface","title":"DifferentiationInterface.value_and_pullback","text":"value_and_pullback(backend, f, x, dy, [extras]) -> (y, dx)\n\nCompute the primal value y = f(x) and the vector-Jacobian product dx = ∂f(x)' * dy.\n\n\n\n\n\n","category":"function"},{"location":"interface/#DifferentiationInterface.value_and_pullback!","page":"Interface","title":"DifferentiationInterface.value_and_pullback!","text":"value_and_pullback!(dx, backend, f, x, dy, [extras]) -> (y, dx)\n\nCompute the primal value y = f(x) and the vector-Jacobian product dx = ∂f(x)' * dy, overwriting dx if possible.\n\ninfo: Interface requirement\nThis is the only required implementation for a reverse mode backend.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Backends","page":"Interface","title":"Backends","text":"","category":"section"},{"location":"interface/#ADTypes.jl","page":"Interface","title":"ADTypes.jl","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The following backends are defined by ADTypes.jl:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"AbstractADType","category":"page"},{"location":"interface/#ADTypes.AbstractADType","page":"Interface","title":"ADTypes.AbstractADType","text":"Base type for AD choices.\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"Only a subset is supported by DifferentiationInterface.jl at the moment.","category":"page"},{"location":"interface/#DifferentiationInterface.jl","page":"Interface","title":"DifferentiationInterface.jl","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The following backends are defined by DifferentiationInterface.jl:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"backends.jl\"]\nOrder   = [:type]\nPrivate = false","category":"page"},{"location":"interface/#DifferentiationInterface.AutoChainRules","page":"Interface","title":"DifferentiationInterface.AutoChainRules","text":"AutoChainRules{RC}\n\nEnables the use of AD libraries based on ChainRulesCore.jl.\n\nFields\n\nruleconfig::RC: a RuleConfig object\n\nExample\n\nusing DifferentiationInterface, Zygote\nbackend = AutoChainRules(Zygote.ZygoteRuleConfig())\n\n\n\n\n\n","category":"type"},{"location":"interface/#DifferentiationInterface.AutoDiffractor","page":"Interface","title":"DifferentiationInterface.AutoDiffractor","text":"AutoDiffractor\n\nEnables the use of Diffractor.jl.\n\n\n\n\n\n","category":"type"},{"location":"interface/#Input-/-output-types","page":"Interface","title":"Input / output types","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"backends.jl\"]\nOrder   = [:function]\nPrivate = false","category":"page"},{"location":"interface/#DifferentiationInterface.handles_input_type-Tuple{ADTypes.AbstractADType, Type{<:Number}}","page":"Interface","title":"DifferentiationInterface.handles_input_type","text":"handles_input_type(backend, ::Type{X})\n\nCheck if backend can differentiate functions with input type X.\n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.handles_output_type-Tuple{ADTypes.AbstractADType, Type{<:Number}}","page":"Interface","title":"DifferentiationInterface.handles_output_type","text":"handles_output_type(backend, ::Type{Y})\n\nCheck if backend can differentiate functions with output type Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.handles_types-Union{Tuple{Y}, Tuple{X}, Tuple{ADTypes.AbstractADType, Type{X}, Type{Y}}} where {X, Y}","page":"Interface","title":"DifferentiationInterface.handles_types","text":"handles_types(backend, ::Type{X}, ::Type{Y})\n\nCheck if backend can differentiate functions with input type X and output type Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Internals","page":"Interface","title":"Internals","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [DifferentiationInterface]\nPages = [\"implem.jl\", \"mode.jl\", \"utils.jl\", \"backends.jl\"]\nPublic = false","category":"page"},{"location":"interface/#DifferentiationInterface.CustomImplem","page":"Interface","title":"DifferentiationInterface.CustomImplem","text":"CustomImplem\n\nTrait specifying that the custom utilities from the backend should be used as much as possible. Used for internal dispatch only.\n\n\n\n\n\n","category":"type"},{"location":"interface/#DifferentiationInterface.FallbackImplem","page":"Interface","title":"DifferentiationInterface.FallbackImplem","text":"FallbackImplem\n\nTrait specifying that the fallback utilities from DifferentiationInterface.jl should be used as much as possible, until they call a pushforward or pullback. Used for internal dispatch only.\n\n\n\n\n\n","category":"type"},{"location":"interface/#DifferentiationInterface.ForwardMode","page":"Interface","title":"DifferentiationInterface.ForwardMode","text":"ForwardMode\n\nTrait identifying forward mode AD backends. Used for internal dispatch only.\n\n\n\n\n\n","category":"type"},{"location":"interface/#DifferentiationInterface.ReverseMode","page":"Interface","title":"DifferentiationInterface.ReverseMode","text":"ReverseMode\n\nTrait identifying reverse mode AD backends. Used for internal dispatch only.\n\n\n\n\n\n","category":"type"},{"location":"interface/#DifferentiationInterface.basisarray-Tuple{ADTypes.AbstractADType, AbstractArray, Any}","page":"Interface","title":"DifferentiationInterface.basisarray","text":"basisarray(backend, a::AbstractArray, i::CartesianIndex)\n\nConstruct the i-th stardard basis array in the vector space of a with element type eltype(a).\n\nNote\n\nIf an AD backend benefits from a more specialized basis array implementation, this function can be extended on the backend type.\n\n\n\n\n\n","category":"method"},{"location":"interface/#DifferentiationInterface.autodiff_mode-Tuple{ADTypes.AbstractForwardMode}","page":"Interface","title":"DifferentiationInterface.autodiff_mode","text":"autodiff_mode(backend)\n\nReturn ForwardMode() or ReverseMode() in a statically predictable way.\n\nThis function must be overloaded for backends that do not inherit from ADTypes.AbstractForwardMode or ADTypes.AbstractReverseMode (e.g. because they support both forward and reverse).\n\nWe classify ADTypes.AbstractFiniteDifferencesMode as forward mode.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"https://github.com/gdalle/DifferentiationInterface.jl/blob/main/README.md\"","category":"page"},{"location":"#DifferentiationInterface","page":"Home","title":"DifferentiationInterface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"An interface to various automatic differentiation backends in Julia.","category":"page"},{"location":"#Goal","page":"Home","title":"Goal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a backend-agnostic syntax to differentiate functions f(x) = y, where x and y are either numbers or abstract arrays.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It started out as an experimental redesign for AbstractDifferentiation.jl.","category":"page"},{"location":"#Compatibility","page":"Home","title":"Compatibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We support some of the backends defined by ADTypes.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Enzyme.jl with AutoEnzyme(Val(:forward)) or AutoEnzyme(Val(:reverse))\nFiniteDiff.jl with AutoFiniteDiff()\nForwardDiff.jl with AutoForwardDiff()\nPolyesterForwardDiff.jl with AutoPolyesterForwardDiff(; chunksize=C)\nReverseDiff.jl with AutoReverseDiff()\nZygote.jl with AutoZygote()","category":"page"},{"location":"","page":"Home","title":"Home","text":"We also support two more backends which are not yet part of ADTypes.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ChainRulesCore.jl with AutoChainRules(ruleconfig)\nDiffractor.jl with AutoDiffractor()","category":"page"},{"location":"#Design","page":"Home","title":"Design","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each backend must implement only one primitive:","category":"page"},{"location":"","page":"Home","title":"Home","text":"forward mode: the pushforward, computing a Jacobian-vector product\nreverse mode: the pullback, computing a vector-Jacobian product","category":"page"},{"location":"","page":"Home","title":"Home","text":"From these primitives, several utilities are defined, depending on the type of the input and output:","category":"page"},{"location":"","page":"Home","title":"Home","text":" scalar output array output\nscalar input derivative multiderivative\narray input gradient jacobian","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> import DifferentiationInterface, ADTypes, ForwardDiff\n\njulia> backend = ADTypes.AutoForwardDiff();\n\njulia> f(x) = sum(abs2, x);\n\njulia> DifferentiationInterface.value_and_gradient(backend, f, [1., 2., 3.])\n(14.0, [2.0, 4.0, 6.0])","category":"page"}]
}
