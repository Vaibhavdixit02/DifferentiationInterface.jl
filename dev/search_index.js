var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API reference","title":"API reference","text":"CurrentModule = DifferentiationInterface\nCollapsedDocStrings = true","category":"page"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"DifferentiationInterface","category":"page"},{"location":"api/#DifferentiationInterface.DifferentiationInterface","page":"API reference","title":"DifferentiationInterface.DifferentiationInterface","text":"DifferentiationInterface\n\nAn experimental redesign for AbstractDifferentiation.jl.\n\nExports\n\nChainRulesForwardBackend\nChainRulesReverseBackend\nEnzymeForwardBackend\nEnzymeReverseBackend\nFiniteDiffBackend\nForwardDiffBackend\nReverseDiffBackend\nvalue_and_derivative\nvalue_and_gradient\nvalue_and_gradient!\nvalue_and_jacobian\nvalue_and_jacobian!\nvalue_and_multiderivative\nvalue_and_multiderivative!\nvalue_and_pullback\nvalue_and_pullback!\nvalue_and_pushforward\nvalue_and_pushforward!\n\n\n\n\n\n","category":"module"},{"location":"api/#Backends","page":"API reference","title":"Backends","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [DifferentiationInterface]\nPages = [\"backends.jl\"]","category":"page"},{"location":"api/#DifferentiationInterface.ChainRulesForwardBackend","page":"API reference","title":"DifferentiationInterface.ChainRulesForwardBackend","text":"ChainRulesForwardBackend{RC}\n\nPerforms autodiff with forward-mode AD packages based on ChainRulesCore.jl, like Diffractor.jl.\n\nThis must be constructed with an appropriate RuleConfig instance.\n\nusing Diffractor, DifferentiationInterface\nbackend = ChainRulesForwardBackend(Diffractor.DiffractorRuleConfig())\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.ChainRulesReverseBackend","page":"API reference","title":"DifferentiationInterface.ChainRulesReverseBackend","text":"ChainRulesReverseBackend{RC}\n\nPerforms autodiff with reverse-mode AD packages based on ChainRulesCore.jl, like Zygote.jl.\n\nThis must be constructed with an appropriate RuleConfig instance:\n\nusing Zygote, DifferentiationInterface\nbackend = ChainRulesReverseBackend(Zygote.ZygoteRuleConfig())\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.EnzymeForwardBackend","page":"API reference","title":"DifferentiationInterface.EnzymeForwardBackend","text":"EnzymeForwardBackend\n\nPerforms forward-mode autodiff with Enzyme.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.EnzymeReverseBackend","page":"API reference","title":"DifferentiationInterface.EnzymeReverseBackend","text":"EnzymeReverseBackend\n\nPerforms reverse-mode autodiff with Enzyme.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.FiniteDiffBackend","page":"API reference","title":"DifferentiationInterface.FiniteDiffBackend","text":"FiniteDiffBackend\n\nPerforms autodiff with FiniteDiff.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.ForwardDiffBackend","page":"API reference","title":"DifferentiationInterface.ForwardDiffBackend","text":"ForwardDiffBackend\n\nPerforms autodiff with ForwardDiff.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.ReverseDiffBackend","page":"API reference","title":"DifferentiationInterface.ReverseDiffBackend","text":"ReverseDiffBackend\n\nPerforms autodiff with ReverseDiff.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/#Primitives","page":"API reference","title":"Primitives","text":"","category":"section"},{"location":"api/#Pushforward","page":"API reference","title":"Pushforward","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [DifferentiationInterface]\nPages = [\"pushforward.jl\"]","category":"page"},{"location":"api/#DifferentiationInterface.value_and_pushforward!-Tuple{Any, DifferentiationInterface.AbstractBackend, Any, Any, Any}","page":"API reference","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(dy, backend, f, x, dx[, stuff]) -> (y, dy)\n\nCompute the Jacobian-vector product of the Jacobian of f at x with dx inside dy. Returns the primal output f(x) and the JVP dy.\n\ninfo: Interface requirement\nThis is the only required implementation for a forward mode backend.\n\nArguments\n\ny: primal output\ndy: cotangent, might be modified\nbackend: forward-mode autodiff backend\nf: function x -> y to differentiate\nx: argument\ndx: tangent\nstuff: optional backend-specific storage (cache, config), might be modified\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterface.value_and_pushforward-Tuple{DifferentiationInterface.AbstractBackend, Any, Any, Any}","page":"API reference","title":"DifferentiationInterface.value_and_pushforward","text":"value_and_pushforward(backend, f, x, dx[, stuff]) -> (y, dy)\n\nCall value_and_pushforward! after allocating memory for the Jacobian-vector product.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pullback","page":"API reference","title":"Pullback","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [DifferentiationInterface]\nPages = [\"pullback.jl\"]","category":"page"},{"location":"api/#DifferentiationInterface.value_and_pullback!-Tuple{Any, DifferentiationInterface.AbstractBackend, Any, Any, Any}","page":"API reference","title":"DifferentiationInterface.value_and_pullback!","text":"value_and_pullback!(dx, backend, f, x, dy[, stuff]) -> (y, dx)\n\nCompute the vector-Jacobian product of dy with the Jacobian of f at x inside dx. Returns the primal output f(x) and the VJP dx.\n\ninfo: Interface requirement\nThis is the only required implementation for a reverse mode backend.\n\nArguments\n\ny: primal output\ndx: tangent, might be modified\nbackend: reverse-mode autodiff backend\nf: function x -> y to differentiate\nx: argument\ndy: cotangent\nstuff: optional backend-specific storage (cache, config), might be modified\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterface.value_and_pullback-Tuple{DifferentiationInterface.AbstractBackend, Any, Any, Any}","page":"API reference","title":"DifferentiationInterface.value_and_pullback","text":"value_and_pullback(backend, f, x, dy[, stuff]) -> (y, dx)\n\nCall value_and_pullback! after allocating memory for the vector-Jacobian product.\n\n\n\n\n\n","category":"method"},{"location":"api/#Special-cases","page":"API reference","title":"Special cases","text":"","category":"section"},{"location":"api/#Scalar-to-scalar","page":"API reference","title":"Scalar to scalar","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [DifferentiationInterface]\nPages = [\"scalar_scalar.jl\"]","category":"page"},{"location":"api/#DifferentiationInterface.value_and_derivative","page":"API reference","title":"DifferentiationInterface.value_and_derivative","text":"value_and_derivative(backend, f, x) -> (y, der)\n\nCompute the derivative of a scalar-to-scalar function. Returns the primal output f(x) and the derivative.\n\n\n\n\n\n","category":"function"},{"location":"api/#Scalar-to-array","page":"API reference","title":"Scalar to array","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [DifferentiationInterface]\nPages = [\"scalar_array.jl\"]","category":"page"},{"location":"api/#DifferentiationInterface.value_and_multiderivative!","page":"API reference","title":"DifferentiationInterface.value_and_multiderivative!","text":"value_and_multiderivative!(multider, backend, f, x) -> (y, multider)\n\nCompute the derivative of a scalar-to-array function inside multider. Returns the primal output f(x) and the derivative.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.value_and_multiderivative-Tuple{DifferentiationInterface.AbstractBackend, Any, Number}","page":"API reference","title":"DifferentiationInterface.value_and_multiderivative","text":"value_and_multiderivative(backend, f, x) -> (y, multider)\n\nCall value_and_multiderivative! after allocating memory for the multiderivative.\n\n\n\n\n\n","category":"method"},{"location":"api/#Array-to-scalar","page":"API reference","title":"Array to scalar","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [DifferentiationInterface]\nPages = [\"array_scalar.jl\"]","category":"page"},{"location":"api/#DifferentiationInterface.value_and_gradient!","page":"API reference","title":"DifferentiationInterface.value_and_gradient!","text":"value_and_gradient!(grad, backend, f, x) -> (y, grad)\n\nCompute the gradient of an array-to-scalar function inside dx. Returns the primal output f(x) and the gradient.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.value_and_gradient-Tuple{DifferentiationInterface.AbstractBackend, Any, AbstractArray}","page":"API reference","title":"DifferentiationInterface.value_and_gradient","text":"value_and_gradient(backend, f, x) -> (y, grad)\n\nCall value_and_gradient! after allocating memory for the gradient.\n\n\n\n\n\n","category":"method"},{"location":"api/#Array-to-array","page":"API reference","title":"Array to array","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [DifferentiationInterface]\nPages = [\"array_array.jl\"]","category":"page"},{"location":"api/#DifferentiationInterface.value_and_jacobian!-Tuple{AbstractMatrix, DifferentiationInterface.AbstractBackend, Any, AbstractArray}","page":"API reference","title":"DifferentiationInterface.value_and_jacobian!","text":"value_and_jacobian!(jac, backend, f, x[, stuff]) -> (y, jac)\n\nCompute the Jacobian inside jac. Returns the primal output f(x) and the Jacobian.\n\nNotes\n\nFor a function f: ℝⁿ → ℝᵐ, jac is expected to be a m × n matrix. If the input or output is a higher-order array, it is flattened with vec.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterface.value_and_jacobian-Tuple{DifferentiationInterface.AbstractBackend, Any, AbstractArray}","page":"API reference","title":"DifferentiationInterface.value_and_jacobian","text":"value_and_jacobian(backend, f, x) -> (y, jac)\n\nCall value_and_jacobian! after allocating memory for the Jacobian matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#Internals","page":"API reference","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [DifferentiationInterface]\nPublic = false","category":"page"},{"location":"api/#DifferentiationInterface.basisarray-Tuple{DifferentiationInterface.AbstractBackend, AbstractArray, Any}","page":"API reference","title":"DifferentiationInterface.basisarray","text":"basisarray(backend, a::AbstractArray, i)\n\nConstruct the i-th stardard basis array in the vector space of a with element type eltype(a).\n\nNote\n\nIf an AD backend benefits from a more specialized unit vector implementation, this function can be extended on the backend type.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DifferentiationInterface\nCollapsedDocStrings = true","category":"page"},{"location":"#DifferentiationInterface","page":"Home","title":"DifferentiationInterface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DifferentiationInterface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is an interface to various autodiff backends for differentiating functions of the form f(x) = y, where x and y are either numbers or abstract arrays.","category":"page"},{"location":"#Terminology","page":"Home","title":"Terminology","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":" scalar output vector output\nscalar input derivative multiderivative\nvector input gradient jacobian","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"CollapsedDocStrings = true","category":"page"},{"location":"extensions/#Extensions","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"extensions/#ChainRulesCore","page":"Extensions","title":"ChainRulesCore","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Modules = [DIChainRulesCoreExt]","category":"page"},{"location":"extensions/#DifferentiationInterface.value_and_pullback!-Union{Tuple{Y}, Tuple{X}, Tuple{Any, ChainRulesReverseBackend, Any, X, Y}} where {X, Y}","page":"Extensions","title":"DifferentiationInterface.value_and_pullback!","text":"value_and_pullback!(\n    dx,\n    backend::ChainRulesReverseBackend,\n    f,\n    x,\n    dy\n) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"extensions/#DifferentiationInterface.value_and_pushforward!-Union{Tuple{Y}, Tuple{X}, Tuple{Y, ChainRulesForwardBackend, Any, X, Any}} where {X, Y}","page":"Extensions","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(\n    dy,\n    backend::ChainRulesForwardBackend,\n    f,\n    x,\n    dx\n) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"extensions/#Enzyme","page":"Extensions","title":"Enzyme","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Modules = [DIEnzymeExt]","category":"page"},{"location":"extensions/#DifferentiationInterface.value_and_pushforward!-Union{Tuple{Y}, Tuple{X}, Tuple{Y, EnzymeForwardBackend, Any, X, Any}} where {X, Y<:AbstractArray}","page":"Extensions","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(\n    dy::AbstractArray,\n    _::EnzymeForwardBackend,\n    f,\n    x,\n    dx\n) -> Tuple{Any, AbstractArray}\n\n\n\n\n\n\n","category":"method"},{"location":"extensions/#DifferentiationInterface.value_and_pushforward!-Union{Tuple{Y}, Tuple{X}, Tuple{Y, EnzymeForwardBackend, Any, X, Any}} where {X, Y<:Real}","page":"Extensions","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(\n    _dy::Real,\n    _::EnzymeForwardBackend,\n    f,\n    x,\n    dx\n) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"extensions/#FiniteDiff","page":"Extensions","title":"FiniteDiff","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Modules = [DIFiniteDiffExt]","category":"page"},{"location":"extensions/#DifferentiationInterface.value_and_pushforward!-Union{Tuple{Y}, Tuple{X}, Tuple{Y, FiniteDiffBackend, Any, X, Any}} where {X<:AbstractArray, Y<:AbstractArray}","page":"Extensions","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(\n    dy::AbstractArray,\n    _::FiniteDiffBackend,\n    f,\n    x::AbstractArray,\n    dx\n) -> Tuple{Any, AbstractArray}\n\n\n\n\n\n\n","category":"method"},{"location":"extensions/#DifferentiationInterface.value_and_pushforward!-Union{Tuple{Y}, Tuple{X}, Tuple{Y, FiniteDiffBackend, Any, X, Any}} where {X<:AbstractArray, Y<:Number}","page":"Extensions","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(\n    dy::Number,\n    _::FiniteDiffBackend,\n    f,\n    x::AbstractArray,\n    dx\n) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"extensions/#DifferentiationInterface.value_and_pushforward!-Union{Tuple{Y}, Tuple{X}, Tuple{Y, FiniteDiffBackend, Any, X, Any}} where {X<:Number, Y<:AbstractArray}","page":"Extensions","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(\n    dy::AbstractArray,\n    _::FiniteDiffBackend,\n    f,\n    x::Number,\n    dx\n) -> Tuple{Any, AbstractArray}\n\n\n\n\n\n\n","category":"method"},{"location":"extensions/#DifferentiationInterface.value_and_pushforward!-Union{Tuple{Y}, Tuple{X}, Tuple{Y, FiniteDiffBackend, Any, X, Any}} where {X<:Number, Y<:Number}","page":"Extensions","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(\n    dy::Number,\n    _::FiniteDiffBackend,\n    f,\n    x::Number,\n    dx\n) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"extensions/#ForwardDiff","page":"Extensions","title":"ForwardDiff","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Modules = [DIForwardDiffExt]","category":"page"},{"location":"extensions/#DifferentiationInterface.value_and_pushforward!-Union{Tuple{Y}, Tuple{X}, Tuple{Y, ForwardDiffBackend, Any, X, Any}} where {X<:AbstractArray, Y<:AbstractArray}","page":"Extensions","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(\n    dy::AbstractArray,\n    _::ForwardDiffBackend,\n    f,\n    x::AbstractArray,\n    dx\n) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"extensions/#DifferentiationInterface.value_and_pushforward!-Union{Tuple{Y}, Tuple{X}, Tuple{Y, ForwardDiffBackend, Any, X, Any}} where {X<:AbstractArray, Y<:Real}","page":"Extensions","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(\n    _dy::Real,\n    _::ForwardDiffBackend,\n    f,\n    x::AbstractArray,\n    dx\n) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"extensions/#DifferentiationInterface.value_and_pushforward!-Union{Tuple{Y}, Tuple{X}, Tuple{Y, ForwardDiffBackend, Any, X, Any}} where {X<:Real, Y<:AbstractArray}","page":"Extensions","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(\n    dy::AbstractArray,\n    _::ForwardDiffBackend,\n    f,\n    x::Real,\n    dx\n) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"extensions/#DifferentiationInterface.value_and_pushforward!-Union{Tuple{Y}, Tuple{X}, Tuple{Y, ForwardDiffBackend, Any, X, Any}} where {X<:Real, Y<:Real}","page":"Extensions","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(\n    _dy::Real,\n    _::ForwardDiffBackend,\n    f,\n    x::Real,\n    dx\n) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"extensions/#ReverseDiff","page":"Extensions","title":"ReverseDiff","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Modules = [DIReverseDiffExt]","category":"page"},{"location":"extensions/#DifferentiationInterface.value_and_pullback!-Union{Tuple{Y}, Tuple{X}, Tuple{Any, ReverseDiffBackend, Any, X, Y}} where {X<:AbstractArray, Y<:AbstractArray}","page":"Extensions","title":"DifferentiationInterface.value_and_pullback!","text":"value_and_pullback!(\n    dx,\n    _::ReverseDiffBackend,\n    f,\n    x::AbstractArray,\n    dy::AbstractArray\n) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"extensions/#DifferentiationInterface.value_and_pullback!-Union{Tuple{Y}, Tuple{X}, Tuple{Any, ReverseDiffBackend, Any, X, Y}} where {X<:AbstractArray, Y<:Real}","page":"Extensions","title":"DifferentiationInterface.value_and_pullback!","text":"value_and_pullback!(\n    dx,\n    _::ReverseDiffBackend,\n    f,\n    x::AbstractArray,\n    dy::Real\n) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"extensions/#Zygote","page":"Extensions","title":"Zygote","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Modules = [DIZygoteExt]","category":"page"}]
}
