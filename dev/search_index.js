var documenterSearchIndex = {"docs":
[{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"CurrentModule = Main","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We present a typical workflow with DifferentiationInterface.jl and showcase its potential performance benefits.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DifferentiationInterface\nusing BenchmarkTools\nimport ForwardDiff, Enzyme, DataFrames","category":"page"},{"location":"tutorial/#Computing-a-gradient","page":"Tutorial","title":"Computing a gradient","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A common use case of AD is optimizing real-valued functions with first- or second-order methods. Let's define a simple objective","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f(x::AbstractArray) = sum(abs2, x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and a random input vector","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x = [1.0, 2.0, 3.0]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To compute its gradient, we need to choose a \"backend\", i.e. an AD package that DifferentiationInterface.jl will call under the hood. ForwardDiff.jl is very efficient for low-dimensional inputs, so we'll go with that one. Most backend types are defined by ADTypes.jl and re-exported by DifferentiationInterface.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"backend = AutoForwardDiff()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can use DifferentiationInterface.jl to get our gradient:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"gradient(f, backend, x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Was that fast? We can use BenchmarkTools.jl to answer that question.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@btime gradient($f, $backend, $x);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"More or less what you would get if you just used the API from ForwardDiff.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@btime ForwardDiff.gradient($f, $x);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Not bad, but we can do better.","category":"page"},{"location":"tutorial/#Overwriting-a-gradient","page":"Tutorial","title":"Overwriting a gradient","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Since we know how much space our gradient will occupy, we can pre-allocate that memory and offer it to AD. Some backends can get a speed boost from this trick.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"grad = zero(x)\ngrad = gradient!!(f, grad, backend, x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note the double exclamation mark, which is a convention telling you that grad may or may not be overwritten, but will be returned either way (see this section for more details).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@btime gradient!!($f, _grad, $backend, $x) evals=1 setup=(_grad=similar($x));","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For some reason the in-place version is not much better than our first attempt. However, as you can see, it has one less allocation: it corresponds to the gradient vector we provided. Don't worry, we're not done yet.","category":"page"},{"location":"tutorial/#Preparing-for-multiple-gradients","page":"Tutorial","title":"Preparing for multiple gradients","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Internally, ForwardDiff.jl creates some data structures to keep track of things. These objects can be reused between gradient computations, even on different input values. We abstract away the preparation step behind a backend-agnostic syntax:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"extras = prepare_gradient(f, backend, x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You don't need to know what that is, you just need to pass it to the gradient operator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"grad = zero(x);\ngrad = gradient!!(f, grad, backend, x, extras)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Why, you ask? Because it is much faster, and allocation-free.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@btime gradient!!($f, _grad, $backend, $x, _extras) evals=1 setup=(\n    _grad=similar($x);\n    _extras=prepare_gradient($f, $backend, $x)\n);","category":"page"},{"location":"tutorial/#Switching-backends","page":"Tutorial","title":"Switching backends","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now the whole point of DifferentiationInterface.jl is that you can easily experiment with different AD solutions. Typically, for gradients, reverse mode AD might be a better fit. So let's try the state-of-the-art Enzyme.jl!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For this one, the backend definition is slightly more involved, because you need to feed the \"mode\" to the object from ADTypes.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"backend2 = AutoEnzyme(Enzyme.Reverse)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"But once it is done, things run smoothly with exactly the same syntax:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"gradient(f, backend2, x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And we can run the same benchmarks:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@btime gradient!!($f, _grad, $backend2, $x, _extras) evals=1 setup=(\n    _grad=similar($x);\n    _extras=prepare_gradient($f, $backend2, $x)\n);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Have you seen this? It's blazingly fast. And you know what's even better? You didn't need to look at the docs of either ForwardDiff.jl or Enzyme.jl to achieve top performance with both, or to compare them.","category":"page"},{"location":"tutorial/#Testing","page":"Tutorial","title":"Testing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DifferentiationInterface.jl also provides some utilities for more involved comparison between backends. They are gathered in a submodule called DifferentiationInterfaceTest, located here in the repo.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DifferentiationInterfaceTest","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For testing, you can use test_differentiation as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"test_differentiation(\n    [AutoForwardDiff(), AutoEnzyme(Enzyme.Reverse)],  # backends to compare\n    [GradientScenario(f; x=rand(3)), GradientScenario(f; x=rand(3,3))];  # test scenarios\n    correctness=AutoZygote(),  # compare results to a \"ground truth\" from Zygote\n    detailed=true,  # print detailed test log\n);","category":"page"},{"location":"tutorial/#Benchmarking","page":"Tutorial","title":"Benchmarking","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once you have ascertained correctness, performance will be your next concern. The interface of benchmark_differentiation is very similar to the one we've just seen, but this time it returns a data object.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"data = benchmark_differentiation(\n    [AutoForwardDiff(), AutoEnzyme(Enzyme.Reverse)],\n    [GradientScenario(f; x=rand(3)), GradientScenario(f; x=rand(3,3))];\n);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The resulting object is just a vector of structs, and you can easily convert to a DataFrame from DataFrames.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"df = DataFrames.DataFrame(data)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here's what the resulting DataFrame looks like with all its columns. Note that the results may vary from the ones presented above (we use Chairmarks.jl internally instead of BenchmarkTools.jl, and measure slightly different operators).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"import Markdown, PrettyTables  # hide\nMarkdown.parse(PrettyTables.pretty_table(String, df; backend=Val(:markdown), header=names(df)))  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"core/","page":"Core API","title":"Core API","text":"CurrentModule = Main\nCollapsedDocStrings = true","category":"page"},{"location":"core/#Core-API","page":"Core API","title":"Core API","text":"","category":"section"},{"location":"core/","page":"Core API","title":"Core API","text":"DifferentiationInterface","category":"page"},{"location":"core/#DifferentiationInterface","page":"Core API","title":"DifferentiationInterface","text":"DifferentiationInterface\n\nAn interface to various automatic differentiation backends in Julia.\n\nExports\n\nAutoChainRules\nAutoDiffractor\nAutoEnzyme\nAutoFastDifferentiation\nAutoFiniteDiff\nAutoFiniteDifferences\nAutoForwardDiff\nAutoPolyesterForwardDiff\nAutoReverseDiff\nAutoSparseFastDifferentiation\nAutoSparseFiniteDiff\nAutoSparseForwardDiff\nAutoSparsePolyesterForwardDiff\nAutoSparseReverseDiff\nAutoSparseZygote\nAutoTapir\nAutoTracker\nAutoZygote\nSecondOrder\ncheck_available\ncheck_hessian\ncheck_mutation\nderivative\nderivative!!\ngradient\ngradient!!\nhessian\nhessian!!\nhvp\nhvp!!\njacobian\njacobian!!\nprepare_derivative\nprepare_gradient\nprepare_hessian\nprepare_hvp\nprepare_jacobian\nprepare_pullback\nprepare_pushforward\nprepare_second_derivative\npullback\npullback!!\npushforward\npushforward!!\nsecond_derivative\nsecond_derivative!!\nvalue_and_derivative\nvalue_and_derivative!!\nvalue_and_gradient\nvalue_and_gradient!!\nvalue_and_jacobian\nvalue_and_jacobian!!\nvalue_and_pullback\nvalue_and_pullback!!\nvalue_and_pushforward\nvalue_and_pushforward!!\n\n\n\n\n\n","category":"module"},{"location":"core/#Derivative","page":"Core API","title":"Derivative","text":"","category":"section"},{"location":"core/","page":"Core API","title":"Core API","text":"Modules = [DifferentiationInterface]\nPages = [\"src/derivative.jl\"]\nPrivate = false","category":"page"},{"location":"core/#DifferentiationInterface.derivative","page":"Core API","title":"DifferentiationInterface.derivative","text":"derivative(f, backend, x, [extras]) -> der\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.derivative!!","page":"Core API","title":"DifferentiationInterface.derivative!!","text":"derivative!!(f, der, backend, x, [extras]) -> der\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.prepare_derivative-Tuple{DifferentiationInterface.Extras, Any, ADTypes.AbstractADType, Vararg{Any}}","page":"Core API","title":"DifferentiationInterface.prepare_derivative","text":"prepare_derivative([other_extras], f, backend, x) -> extras\nprepare_derivative([other_extras], f!, backend, y, x) -> extras\n\nCreate an extras object subtyping DerivativeExtras that can be given to derivative operators.\n\n\n\n\n\n","category":"method"},{"location":"core/#DifferentiationInterface.value_and_derivative","page":"Core API","title":"DifferentiationInterface.value_and_derivative","text":"value_and_derivative(f, backend, x, [extras]) -> (y, der)\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.value_and_derivative!!","page":"Core API","title":"DifferentiationInterface.value_and_derivative!!","text":"value_and_derivative!!(f, der, backend, x, [extras]) -> (y, der)\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.value_and_derivative!!-2","page":"Core API","title":"DifferentiationInterface.value_and_derivative!!","text":"value_and_derivative!!(f!, y, der, backend, x, [extras]) -> (y, der)\n\n\n\n\n\n","category":"function"},{"location":"core/#Gradient","page":"Core API","title":"Gradient","text":"","category":"section"},{"location":"core/","page":"Core API","title":"Core API","text":"Modules = [DifferentiationInterface]\nPages = [\"gradient.jl\"]\nPrivate = false","category":"page"},{"location":"core/#DifferentiationInterface.gradient","page":"Core API","title":"DifferentiationInterface.gradient","text":"gradient(f, backend, x, [extras]) -> grad\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.gradient!!","page":"Core API","title":"DifferentiationInterface.gradient!!","text":"gradient!!(f, grad, backend, x, [extras]) -> grad\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.prepare_gradient-Tuple{DifferentiationInterface.Extras, Any, ADTypes.AbstractADType, Vararg{Any}}","page":"Core API","title":"DifferentiationInterface.prepare_gradient","text":"prepare_gradient([other_extras], f, backend, x) -> extras\n\nCreate an extras object subtyping GradientExtras that can be given to gradient operators.\n\n\n\n\n\n","category":"method"},{"location":"core/#DifferentiationInterface.value_and_gradient","page":"Core API","title":"DifferentiationInterface.value_and_gradient","text":"value_and_gradient(f, backend, x, [extras]) -> (y, grad)\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.value_and_gradient!!","page":"Core API","title":"DifferentiationInterface.value_and_gradient!!","text":"value_and_gradient!!(f, grad, backend, x, [extras]) -> (y, grad)\n\n\n\n\n\n","category":"function"},{"location":"core/#Jacobian","page":"Core API","title":"Jacobian","text":"","category":"section"},{"location":"core/","page":"Core API","title":"Core API","text":"Modules = [DifferentiationInterface]\nPages = [\"jacobian.jl\"]\nPrivate = false","category":"page"},{"location":"core/#DifferentiationInterface.jacobian","page":"Core API","title":"DifferentiationInterface.jacobian","text":"jacobian(f, backend, x, [extras]) -> jac\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.jacobian!!","page":"Core API","title":"DifferentiationInterface.jacobian!!","text":"jacobian!!(f, jac, backend, x, [extras]) -> jac\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.prepare_jacobian-Tuple{DifferentiationInterface.Extras, Any, ADTypes.AbstractADType, Vararg{Any}}","page":"Core API","title":"DifferentiationInterface.prepare_jacobian","text":"prepare_jacobian([other_extras], f, backend, x) -> extras\nprepare_jacobian([other_extras], f!, backend, y, x) -> extras\n\nCreate an extras object subtyping JacobianExtras that can be given to Jacobian operators.\n\n\n\n\n\n","category":"method"},{"location":"core/#DifferentiationInterface.value_and_jacobian","page":"Core API","title":"DifferentiationInterface.value_and_jacobian","text":"value_and_jacobian(f, backend, x, [extras]) -> (y, jac)\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.value_and_jacobian!!","page":"Core API","title":"DifferentiationInterface.value_and_jacobian!!","text":"value_and_jacobian!!(f!, y, jac, backend, x, [extras]) -> (y, jac)\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.value_and_jacobian!!-2","page":"Core API","title":"DifferentiationInterface.value_and_jacobian!!","text":"value_and_jacobian!!(f, jac, backend, x, [extras]) -> (y, jac)\n\n\n\n\n\n","category":"function"},{"location":"core/#Second-order","page":"Core API","title":"Second order","text":"","category":"section"},{"location":"core/","page":"Core API","title":"Core API","text":"Modules = [DifferentiationInterface]\nPages = [\"second_order.jl\", \"second_derivative.jl\", \"hessian.jl\", \"hvp.jl\"]\nPrivate = false","category":"page"},{"location":"core/#DifferentiationInterface.SecondOrder","page":"Core API","title":"DifferentiationInterface.SecondOrder","text":"SecondOrder\n\nCombination of two backends for second-order differentiation.\n\nConstructor\n\nSecondOrder(outer, inner)\n\nFields\n\nouter::ADTypes.AbstractADType: backend for the outer differentiation\ninner::ADTypes.AbstractADType: backend for the inner differentiation\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.prepare_second_derivative-Tuple{DifferentiationInterface.Extras, Any, ADTypes.AbstractADType, Vararg{Any}}","page":"Core API","title":"DifferentiationInterface.prepare_second_derivative","text":"prepare_second_derivative([other_extras], f, backend, x) -> extras\nprepare_second_derivative([other_extras], f!, backend, y, x) -> extras\n\nCreate an extras object subtyping SecondDerivativeExtras that can be given to second derivative operators.\n\n\n\n\n\n","category":"method"},{"location":"core/#DifferentiationInterface.second_derivative","page":"Core API","title":"DifferentiationInterface.second_derivative","text":"second_derivative(f, backend, x, [extras]) -> der2\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.second_derivative!!","page":"Core API","title":"DifferentiationInterface.second_derivative!!","text":"second_derivative!!(f, der2, backend, x, [extras]) -> der2\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.hessian","page":"Core API","title":"DifferentiationInterface.hessian","text":"hessian(f, backend, x, [extras]) -> hess\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.hessian!!","page":"Core API","title":"DifferentiationInterface.hessian!!","text":"hessian!!(f, hess, backend, x, [extras]) -> hess\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.prepare_hessian-Tuple{DifferentiationInterface.Extras, Any, ADTypes.AbstractADType, Vararg{Any}}","page":"Core API","title":"DifferentiationInterface.prepare_hessian","text":"prepare_hessian([other_extras], f, backend, x) -> extras\n\nCreate an extras object subtyping HessianExtras that can be given to Hessian operators.\n\n\n\n\n\n","category":"method"},{"location":"core/#DifferentiationInterface.hvp","page":"Core API","title":"DifferentiationInterface.hvp","text":"hvp(f, backend, x, v, [extras]) -> p\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.hvp!!","page":"Core API","title":"DifferentiationInterface.hvp!!","text":"hvp!!(f, p, backend, x, v, [extras]) -> p\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.prepare_hvp-Tuple{DifferentiationInterface.Extras, Any, ADTypes.AbstractADType, Vararg{Any}}","page":"Core API","title":"DifferentiationInterface.prepare_hvp","text":"prepare_hvp([other_extras], f, backend, x) -> extras\n\nCreate an extras object subtyping HVPExtras that can be given to Hessian-vector product operators.\n\n\n\n\n\n","category":"method"},{"location":"core/#Primitives","page":"Core API","title":"Primitives","text":"","category":"section"},{"location":"core/","page":"Core API","title":"Core API","text":"Modules = [DifferentiationInterface]\nPages = [\"pushforward.jl\", \"pullback.jl\"]\nPrivate = false","category":"page"},{"location":"core/#DifferentiationInterface.prepare_pushforward-Tuple{DifferentiationInterface.Extras, Any, ADTypes.AbstractADType, Vararg{Any}}","page":"Core API","title":"DifferentiationInterface.prepare_pushforward","text":"prepare_pushforward([other_extras], f, backend, x) -> extras\nprepare_pushforward([other_extras], f!, backend, y, x) -> extras\n\nCreate an extras object subtyping PushforwardExtras that can be given to pushforward operators.\n\n\n\n\n\n","category":"method"},{"location":"core/#DifferentiationInterface.pushforward","page":"Core API","title":"DifferentiationInterface.pushforward","text":"pushforward(f, backend, x, dx, [extras]) -> (y, dy)\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.pushforward!!","page":"Core API","title":"DifferentiationInterface.pushforward!!","text":"pushforward!!(f, dy, backend, x, dx, [extras]) -> (y, dy)\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.value_and_pushforward","page":"Core API","title":"DifferentiationInterface.value_and_pushforward","text":"value_and_pushforward(f, backend, x, dx, [extras]) -> (y, dy)\n\ninfo: Info\nRequired primitive for forward mode backends to support allocating functions.\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.value_and_pushforward!!","page":"Core API","title":"DifferentiationInterface.value_and_pushforward!!","text":"value_and_pushforward!!(f, dy, backend, x, dx, [extras]) -> (y, dy)\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.value_and_pushforward!!-2","page":"Core API","title":"DifferentiationInterface.value_and_pushforward!!","text":"value_and_pushforward!!(f!, y, dy, backend, x, dx, [extras]) -> (y, dy)\n\ninfo: Info\nRequired primitive for forward mode backends to support mutating functions.\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.prepare_pullback-Tuple{DifferentiationInterface.Extras, Any, ADTypes.AbstractADType, Vararg{Any}}","page":"Core API","title":"DifferentiationInterface.prepare_pullback","text":"prepare_pullback([other_extras], f, backend, x) -> extras\nprepare_pullback([other_extras], f!, backend, y, x) -> extras\n\nCreate an extras object subtyping PullbackExtras that can be given to pullback operators.\n\n\n\n\n\n","category":"method"},{"location":"core/#DifferentiationInterface.pullback","page":"Core API","title":"DifferentiationInterface.pullback","text":"pullback(f, backend, x, dy, [extras]) -> dx\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.pullback!!","page":"Core API","title":"DifferentiationInterface.pullback!!","text":"pullback!!(f, dx, backend, x, dy, [extras]) -> dx\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.value_and_pullback","page":"Core API","title":"DifferentiationInterface.value_and_pullback","text":"value_and_pullback(f, backend, x, dy, [extras]) -> (y, dx)\n\ninfo: Info\nRequired primitive for reverse mode backends to support allocating functions.\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.value_and_pullback!!","page":"Core API","title":"DifferentiationInterface.value_and_pullback!!","text":"value_and_pullback!!(f!, y, dx, backend, x, dy, [extras]) -> (y, dx)\n\ninfo: Info\nRequired primitive for reverse mode backends to support mutating functions.\n\n\n\n\n\n","category":"function"},{"location":"core/#DifferentiationInterface.value_and_pullback!!-2","page":"Core API","title":"DifferentiationInterface.value_and_pullback!!","text":"value_and_pullback!!(f, dx, backend, x, dy, [extras]) -> (y, dx)\n\n\n\n\n\n","category":"function"},{"location":"core/#Backend-queries","page":"Core API","title":"Backend queries","text":"","category":"section"},{"location":"core/","page":"Core API","title":"Core API","text":"Modules = [DifferentiationInterface]\nPages = [\"backends.jl\"]\nPrivate = false","category":"page"},{"location":"core/#DifferentiationInterface.check_available-Tuple{ADTypes.AbstractADType}","page":"Core API","title":"DifferentiationInterface.check_available","text":"check_available(backend)\n\nCheck whether backend is available by trying a scalar-to-scalar derivative.\n\nwarning: Warning\nMight take a while due to compilation time.\n\n\n\n\n\n","category":"method"},{"location":"core/#DifferentiationInterface.check_hessian-Tuple{ADTypes.AbstractADType}","page":"Core API","title":"DifferentiationInterface.check_hessian","text":"check_hessian(backend)\n\nCheck whether backend supports second order differentiation by trying a hessian.\n\nwarning: Warning\nMight take a while due to compilation time.\n\n\n\n\n\n","category":"method"},{"location":"core/#DifferentiationInterface.check_mutation-Tuple{ADTypes.AbstractADType}","page":"Core API","title":"DifferentiationInterface.check_mutation","text":"check_mutation(backend)\n\nCheck whether backend supports differentiation of mutating functions by trying a jacobian.\n\nwarning: Warning\nMight take a while due to compilation time.\n\n\n\n\n\n","category":"method"},{"location":"core/#Internals","page":"Core API","title":"Internals","text":"","category":"section"},{"location":"core/","page":"Core API","title":"Core API","text":"This is not part of the public API.","category":"page"},{"location":"core/","page":"Core API","title":"Core API","text":"Modules = [DifferentiationInterface]\nPublic = false","category":"page"},{"location":"core/#DifferentiationInterface.DerivativeExtras","page":"Core API","title":"DifferentiationInterface.DerivativeExtras","text":"DerivativeExtras\n\nAbstract type for additional information needed by derivative operators.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.ForwardOverForward","page":"Core API","title":"DifferentiationInterface.ForwardOverForward","text":"ForwardOverForward\n\nTraits identifying second-order backends that compute HVPs in forward over forward mode (inefficient).\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.ForwardOverReverse","page":"Core API","title":"DifferentiationInterface.ForwardOverReverse","text":"ForwardOverReverse\n\nTraits identifying second-order backends that compute HVPs in forward over reverse mode.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.GradientExtras","page":"Core API","title":"DifferentiationInterface.GradientExtras","text":"GradientExtras\n\nAbstract type for additional information needed by gradient operators.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.HVPExtras","page":"Core API","title":"DifferentiationInterface.HVPExtras","text":"HVPExtras\n\nAbstract type for additional information needed by Hessian-vector product operators.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.HessianExtras","page":"Core API","title":"DifferentiationInterface.HessianExtras","text":"HessianExtras\n\nAbstract type for additional information needed by Hessian operators.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.JacobianExtras","page":"Core API","title":"DifferentiationInterface.JacobianExtras","text":"JacobianExtras\n\nAbstract type for additional information needed by Jacobian operators.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.MutationNotSupported","page":"Core API","title":"DifferentiationInterface.MutationNotSupported","text":"MutationNotSupported\n\nTrait identifying backends that do not support mutating functions f!(y, x).\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.MutationSupported","page":"Core API","title":"DifferentiationInterface.MutationSupported","text":"MutationSupported\n\nTrait identifying backends that support mutating functions f!(y, x).\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.PullbackExtras","page":"Core API","title":"DifferentiationInterface.PullbackExtras","text":"PullbackExtras\n\nAbstract type for additional information needed by pullback operators.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.PullbackFast","page":"Core API","title":"DifferentiationInterface.PullbackFast","text":"PullbackFast\n\nTrait identifying backends that support efficient pullbacks.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.PullbackSlow","page":"Core API","title":"DifferentiationInterface.PullbackSlow","text":"PullbackSlow\n\nTrait identifying backends that do not support efficient pullbacks.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.PushforwardExtras","page":"Core API","title":"DifferentiationInterface.PushforwardExtras","text":"PushforwardExtras\n\nAbstract type for additional information needed by pushforward operators.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.PushforwardFast","page":"Core API","title":"DifferentiationInterface.PushforwardFast","text":"PushforwardFast\n\nTrait identifying backends that support efficient pushforwards.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.PushforwardSlow","page":"Core API","title":"DifferentiationInterface.PushforwardSlow","text":"PushforwardSlow\n\nTrait identifying backends that do not support efficient pushforwards.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.ReverseOverForward","page":"Core API","title":"DifferentiationInterface.ReverseOverForward","text":"ReverseOverForward\n\nTraits identifying second-order backends that compute HVPs in reverse over forward mode.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.ReverseOverReverse","page":"Core API","title":"DifferentiationInterface.ReverseOverReverse","text":"ReverseOverReverse\n\nTraits identifying second-order backends that compute HVPs in reverse over reverse mode.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.SecondDerivativeExtras","page":"Core API","title":"DifferentiationInterface.SecondDerivativeExtras","text":"SecondDerivativeExtras\n\nAbstract type for additional information needed by second derivative operators.\n\n\n\n\n\n","category":"type"},{"location":"core/#DifferentiationInterface.basis-Tuple{ADTypes.AbstractADType, AbstractArray, Any}","page":"Core API","title":"DifferentiationInterface.basis","text":"basis(backend, a::AbstractArray, i::CartesianIndex)\n\nConstruct the i-th stardard basis array in the vector space of a with element type eltype(a).\n\nNote\n\nIf an AD backend benefits from a more specialized basis array implementation, this function can be extended on the backend type.\n\n\n\n\n\n","category":"method"},{"location":"core/#DifferentiationInterface.mode-Tuple{ADTypes.AbstractForwardMode}","page":"Core API","title":"DifferentiationInterface.mode","text":"mode(backend)\n\nReturn the AD mode of a backend in a statically predictable way.\n\nThe return value is a Type object chosen among:\n\nADTypes.AbstractForwardMode\nADTypes.AbstractFiniteDifferencesMode\nADTypes.AbstractReverseMode\nADTypes.AbstractSymbolicDifferentiationMode\n\nThis function exists because there are backends (like Enzyme) that can support both forward and reverse mode, which means their ADTypes.jl object does not subtype either.\n\n\n\n\n\n","category":"method"},{"location":"core/#DifferentiationInterface.pullback_performance-Tuple{ADTypes.AbstractADType}","page":"Core API","title":"DifferentiationInterface.pullback_performance","text":"pullback_performance(backend)\n\nReturn PullbackFast or PullbackSlow in a statically predictable way.\n\n\n\n\n\n","category":"method"},{"location":"core/#DifferentiationInterface.pushforward_performance-Tuple{ADTypes.AbstractADType}","page":"Core API","title":"DifferentiationInterface.pushforward_performance","text":"pushforward_performance(backend)\n\nReturn PushforwardFast or PushforwardSlow in a statically predictable way.\n\n\n\n\n\n","category":"method"},{"location":"core/#DifferentiationInterface.supports_mutation-Tuple{ADTypes.AbstractADType}","page":"Core API","title":"DifferentiationInterface.supports_mutation","text":"supports_mutation(backend)\n\nReturn MutationSupported or MutationNotSupported in a statically predictable way.\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core API","title":"Core API","text":"","category":"page"},{"location":"design/#Package-design","page":"Package design","title":"Package design","text":"","category":"section"},{"location":"design/#Backend-requirements","page":"Package design","title":"Backend requirements","text":"","category":"section"},{"location":"design/","page":"Package design","title":"Package design","text":"To be usable with DifferentiationInterface.jl, an AD backend needs an object subtyping ADTypes.AbstractADType. In addition, some operators must be defined:","category":"page"},{"location":"design/","page":"Package design","title":"Package design","text":"backend subtype pushforward necessary pullback necessary\nADTypes.AbstractForwardMode yes no\nADTypes.AbstractFiniteDifferencesMode yes no\nADTypes.AbstractReverseMode no yes\nADTypes.AbstractSymbolicDifferentiationMode yes yes","category":"page"},{"location":"design/","page":"Package design","title":"Package design","text":"Every backend we support corresponds to a package extension of DifferentiationInterface.jl (located in the ext subfolder). Advanced users are welcome to code more backends and submit pull requests!","category":"page"},{"location":"design/#Fallback-call-structure","page":"Package design","title":"Fallback call structure","text":"","category":"section"},{"location":"design/","page":"Package design","title":"Package design","text":"For simplicity, we remove value_ in the operator names below.","category":"page"},{"location":"design/","page":"Package design","title":"Package design","text":"note: Edge labels\nFull edges in the following graphs require a single call to the destination. Dotted edges require multiple calls to the destination, the number is indicated on the edge.","category":"page"},{"location":"design/#First-order","page":"Package design","title":"First order","text":"","category":"section"},{"location":"design/","page":"Package design","title":"Package design","text":"flowchart LR\n    direction LR\n    subgraph Out-of-place\n        pushforward\n        pullback\n        derivative --> pushforward\n        gradient --> pullback\n        jacobian .-> |n|pushforward\n        jacobian .-> |m|pullback\n    end\n\n    subgraph In-place\n        pushforward!! --> pushforward\n        pullback!! --> pullback\n        derivative!! --> pushforward!!\n        gradient!! --> pullback!!\n        jacobian!! .-> |n|pushforward!!\n        jacobian!! .-> |m|pullback!!\n    end\n\n    pushforward .-> |m|pullback\n    pullback .-> |n|pushforward","category":"page"},{"location":"design/","page":"Package design","title":"Package design","text":"","category":"page"},{"location":"testing/","page":"Testing API","title":"Testing API","text":"CurrentModule = Main\nCollapsedDocStrings = true","category":"page"},{"location":"testing/#Testing-API","page":"Testing API","title":"Testing API","text":"","category":"section"},{"location":"testing/","page":"Testing API","title":"Testing API","text":"DifferentiationInterfaceTest","category":"page"},{"location":"testing/#DifferentiationInterfaceTest","page":"Testing API","title":"DifferentiationInterfaceTest","text":"DifferentiationInterfaceTest\n\nTesting utilities for DifferentiationInterface.\n\n\n\n\n\n","category":"module"},{"location":"testing/#Entry-points","page":"Testing API","title":"Entry points","text":"","category":"section"},{"location":"testing/","page":"Testing API","title":"Testing API","text":"test_differentiation\nbenchmark_differentiation","category":"page"},{"location":"testing/#DifferentiationInterfaceTest.test_differentiation","page":"Testing API","title":"DifferentiationInterfaceTest.test_differentiation","text":"test_differentiation(\n    backends::Vector{<:ADTypes.AbstractADType};\n    ...\n)\ntest_differentiation(\n    backends::Vector{<:ADTypes.AbstractADType},\n    scenarios::Vector{<:AbstractScenario};\n    correctness,\n    type_stability,\n    call_count,\n    sparsity,\n    detailed,\n    input_type,\n    output_type,\n    allocating,\n    mutating,\n    first_order,\n    second_order,\n    excluded,\n    logging,\n    isapprox,\n    atol,\n    rtol\n)\n\n\nCross-test a list of backends on a list of scenarios, running a variety of different tests.\n\nDefault arguments\n\nscenarios::Vector{<:AbstractScenario}: the output of default_scenarios()\n\nKeyword arguments\n\nTesting:\n\ncorrectness=true: whether to compare the differentiation results with the theoretical values specified in each scenario\nIf a backend object like correctness=AutoForwardDiff() is passed instead of a boolean, the results will be compared using that reference backend as the ground truth.\nOtherwise, the scenario-specific reference operator will be used as the ground truth instead, see AbstractScenario for details.\ncall_count=false: whether to check that the function is called the right number of times\ntype_stability=false: whether to check type stability with JET.jl (thanks to @test_opt)\nsparsity: whether to check sparsity of the jacobian / hessian\ndetailed=false: whether to print a detailed or condensed test log\n\nFiltering:\n\ninput_type=Any: restrict scenario inputs to subtypes of this\noutput_type=Any: restrict scenario outputs to subtypes of this\nallocating=true: consider operators for allocating functions\nmutating=true: consider operators for mutating functions\nfirst_order=true: consider first order operators\nsecond_order=true: consider second order operators\n\nOptions:\n\nlogging=false: whether to log progress\nisapprox=isapprox: function used to compare objects, with the standard signature isapprox(x, y; atol, rtol)\natol=0: absolute precision for correctness testing (when comparing to the reference outputs)\nrtol=1e-3: relative precision for correctness testing (when comparing to the reference outputs)\n\n\n\n\n\ntest_differentiation(\n    backend::ADTypes.AbstractADType,\n    args...;\n    kwargs...\n)\n\n\nShortcut for a single backend.\n\n\n\n\n\n","category":"function"},{"location":"testing/#DifferentiationInterfaceTest.benchmark_differentiation","page":"Testing API","title":"DifferentiationInterfaceTest.benchmark_differentiation","text":"benchmark_differentiation(\n    backends::Vector{<:ADTypes.AbstractADType};\n    ...\n) -> Vector{DifferentiationInterfaceTest.BenchmarkDataRow}\nbenchmark_differentiation(\n    backends::Vector{<:ADTypes.AbstractADType},\n    scenarios::Vector{<:AbstractScenario};\n    input_type,\n    output_type,\n    allocating,\n    mutating,\n    first_order,\n    second_order,\n    excluded,\n    logging\n) -> Vector{DifferentiationInterfaceTest.BenchmarkDataRow}\n\n\nBenchmark a list of backends for a list of operators on a list of scenarios.\n\nKeyword arguments\n\nfiltering: same as test_differentiation for the filtering part.\nlogging=false: whether to log progress\n\n\n\n\n\n","category":"function"},{"location":"testing/#Pre-made-scenario-lists","page":"Testing API","title":"Pre-made scenario lists","text":"","category":"section"},{"location":"testing/","page":"Testing API","title":"Testing API","text":"default_scenarios\ncomponent_scenarios\ngpu_scenarios\nstatic_scenarios","category":"page"},{"location":"testing/#DifferentiationInterfaceTest.default_scenarios","page":"Testing API","title":"DifferentiationInterfaceTest.default_scenarios","text":"default_scenarios()\n\nCreate a vector of AbstractScenarios with standard array types.\n\n\n\n\n\n","category":"function"},{"location":"testing/#DifferentiationInterfaceTest.component_scenarios","page":"Testing API","title":"DifferentiationInterfaceTest.component_scenarios","text":"component_scenarios()\n\nCreate a vector of AbstractScenarios with component array types from ComponentArrays.jl.\n\n\n\n\n\n","category":"function"},{"location":"testing/#DifferentiationInterfaceTest.gpu_scenarios","page":"Testing API","title":"DifferentiationInterfaceTest.gpu_scenarios","text":"gpu_scenarios()\n\nCreate a vector of AbstractScenarios with GPU array types from JLArrays.jl.\n\n\n\n\n\n","category":"function"},{"location":"testing/#DifferentiationInterfaceTest.static_scenarios","page":"Testing API","title":"DifferentiationInterfaceTest.static_scenarios","text":"static_scenarios()\n\nCreate a vector of AbstractScenarios with static array types from StaticArrays.jl.\n\n\n\n\n\n","category":"function"},{"location":"testing/#Scenario-types","page":"Testing API","title":"Scenario types","text":"","category":"section"},{"location":"testing/","page":"Testing API","title":"Testing API","text":"AbstractScenario\nPushforwardScenario\nPullbackScenario\nDerivativeScenario\nGradientScenario\nJacobianScenario\nSecondDerivativeScenario\nHVPScenario\nHessianScenario","category":"page"},{"location":"testing/#DifferentiationInterfaceTest.AbstractScenario","page":"Testing API","title":"DifferentiationInterfaceTest.AbstractScenario","text":"AbstractScenario\n\nStore a testing scenario composed of a function and its input + output.\n\nThis abstract type should never be used directly: construct one of the subtypes corresponding to the operator you want to test.\n\nSubtypes\n\nPushforwardScenario\nPullbackScenario\nDerivativeScenario\nGradientScenario\nJacobianScenario\nSecondDerivativeScenario\nHVPScenario\nHessianScenario\n\nFields\n\nAll subtypes have the following fields:\n\nf: function to apply\nx: primal input\ny: primal output\nref: reference to compare against\n\nIn addition, some subtypes contain an additional seed (dx or dy).\n\nConstructor\n\nWhen no seed is needed, the constructor looks like\n\nGradientScenario(f; x, y=nothing, ref=nothing)\n\nWhen a seed is needed, the constructor looks like\n\nPushforwardScenario(f; x, y=nothing, ref=nothing, dx=nothing)\n\nIf y is provided, f is interpreted as a mutating function f!(y, x) = nothing. Otherwise, f is interpreted as an allocating function f(x) = y.\n\nThe reference ref should be a function that takes x (and a potential seed dx or dy) to return the correct object.\n\n\n\n\n\n","category":"type"},{"location":"testing/#DifferentiationInterfaceTest.PushforwardScenario","page":"Testing API","title":"DifferentiationInterfaceTest.PushforwardScenario","text":"PushforwardScenario(f; x, y, ref, dx)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"testing/#DifferentiationInterfaceTest.PullbackScenario","page":"Testing API","title":"DifferentiationInterfaceTest.PullbackScenario","text":"PullbackScenario(f; x, y, ref, dy)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"testing/#DifferentiationInterfaceTest.DerivativeScenario","page":"Testing API","title":"DifferentiationInterfaceTest.DerivativeScenario","text":"DerivativeScenario(f; x, y, ref)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"testing/#DifferentiationInterfaceTest.GradientScenario","page":"Testing API","title":"DifferentiationInterfaceTest.GradientScenario","text":"GradientScenario(f; x, y, ref)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"testing/#DifferentiationInterfaceTest.JacobianScenario","page":"Testing API","title":"DifferentiationInterfaceTest.JacobianScenario","text":"JacobianScenario(f; x, y, ref)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"testing/#DifferentiationInterfaceTest.SecondDerivativeScenario","page":"Testing API","title":"DifferentiationInterfaceTest.SecondDerivativeScenario","text":"SecondDerivativeScenario(f; x, y, ref)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"testing/#DifferentiationInterfaceTest.HVPScenario","page":"Testing API","title":"DifferentiationInterfaceTest.HVPScenario","text":"HVPScenario(f; x, y, ref, dx)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"testing/#DifferentiationInterfaceTest.HessianScenario","page":"Testing API","title":"DifferentiationInterfaceTest.HessianScenario","text":"HessianScenario(f; x, y, ref)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"testing/#Internals","page":"Testing API","title":"Internals","text":"","category":"section"},{"location":"testing/","page":"Testing API","title":"Testing API","text":"This is not part of the public API.","category":"page"},{"location":"testing/","page":"Testing API","title":"Testing API","text":"Modules = [DifferentiationInterfaceTest]\nPublic = false","category":"page"},{"location":"testing/#DifferentiationInterfaceTest.AutoZeroForward","page":"Testing API","title":"DifferentiationInterfaceTest.AutoZeroForward","text":"AutoZeroForward <: ADTypes.AbstractForwardMode\n\nTrivial backend that sets all derivatives to zero. Used in testing and benchmarking.\n\n\n\n\n\n","category":"type"},{"location":"testing/#DifferentiationInterfaceTest.AutoZeroReverse","page":"Testing API","title":"DifferentiationInterfaceTest.AutoZeroReverse","text":"AutoZeroReverse <: ADTypes.AbstractReverseMode\n\nTrivial backend that sets all derivatives to zero. Used in testing and benchmarking.\n\n\n\n\n\n","category":"type"},{"location":"testing/#DifferentiationInterfaceTest.BenchmarkDataRow","page":"Testing API","title":"DifferentiationInterfaceTest.BenchmarkDataRow","text":"BenchmarkDataRow\n\nAd-hoc storage type for differentiation benchmarking results. If you have a vector rows::Vector{BenchmarkDataRow}, you can turn it into a DataFrame as follows:\n\ndf = DataFrames.DataFrame(rows)\n\nFields\n\nThese are not part of the public API.\n\nbackend::String\nmode::Type\nscenario::Symbol\noperator::Symbol\nfunc::Symbol\nmutating::Bool\ninput_type::Type\noutput_type::Type\ninput_size::Tuple\noutput_size::Tuple\nsamples::Int64\ntime::Float64\nbytes::Float64\nallocs::Float64\ncompile_fraction::Float64\ngc_fraction::Float64\nevals::Float64\n\n\n\n\n\n","category":"type"},{"location":"testing/","page":"Testing API","title":"Testing API","text":"","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Operators","page":"Overview","title":"Operators","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Depending on the type of input and output, differentiation operators can have various names. Most backends have custom implementations, which we reuse if possible.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We choose the following terminology for the high-level operators we provide:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"operator input  x output   y result type result shape\nderivative Number Any same as y size(y)\ngradient Any Number same as x size(x)\njacobian AbstractArray AbstractArray AbstractMatrix (length(y), length(x))","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"They are all based on the following low-level operators:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"pushforward (or JVP), to propagate input tangents\npullback (or VJP), to backpropagate output cotangents","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"tip: Tip\nSee the book The Elements of Differentiable Programming for details on these concepts.","category":"page"},{"location":"overview/#Variants","page":"Overview","title":"Variants","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Several variants of each operator are defined:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"out-of-place in-place (or not) out-of-place + primal in-place (or not) + primal\nderivative derivative!! value_and_derivative value_and_derivative!!\ngradient gradient!! value_and_gradient value_and_gradient!!\njacobian jacobian!! value_and_jacobian value_and_jacobian!!\npushforward pushforward!! value_and_pushforward value_and_pushforward!!\npullback pullback!! value_and_pullback value_and_pullback!!","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"warning: Warning\nThe \"bang-bang\" syntactic convention !! signals that some of the arguments can be mutated, but they do not have to be. Such arguments will always be part of the return, so that one can simply reuse the operator's output and forget its input. In other words, this is good:# work with grad_in\ngrad_out = gradient!!(f, grad_in, backend, x)\n# work with grad_out: OKOn the other hand, this is bad, because if grad_in has not been mutated, you will forget the results:# work with grad_in\ngradient!!(f, grad_in, backend, x)\n# mistakenly keep working with grad_in: NOT OKNote that we don't guarantee grad_out will have the same type as grad_in.","category":"page"},{"location":"overview/#Second-order","page":"Overview","title":"Second order","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Second-order differentiation is also supported, with the following operators:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"operator input  x output   y result type result shape\nsecond_derivative Number Any same as y size(y)\nhvp Any Number same as x size(x)\nhessian AbstractArray Number AbstractMatrix (length(x), length(x))","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We only define two variants for now:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"out-of-place in-place (or not)\nsecond_derivative second_derivative!!\nhvp hvp!!\nhessian hessian!!","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"danger: Danger\nSecond-order differentiation is still experimental, use at your own risk.","category":"page"},{"location":"overview/#Preparation","page":"Overview","title":"Preparation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"In many cases, AD can be accelerated if the function has been run at least once (e.g. to record a tape) and if some cache objects are provided. This is a backend-specific procedure, but we expose a common syntax to achieve it.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"operator preparation function\nderivative prepare_derivative\ngradient prepare_gradient\njacobian prepare_jacobian\nsecond_derivative prepare_second_derivative\nhessian prepare_hessian\npushforward prepare_pushforward\npullback prepare_pullback\nhvp prepare_hvp","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"If you run prepare_operator(backend, f, x), it will create an object called extras containing the necessary information to speed up operator and its variants. This information is specific to backend and f, as well as the type and size of the input x, but it should work with different values of x.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"You can then call operator(backend, f, similar_x, extras), which should be faster than operator(backend, f, similar_x). This is especially worth it if you plan to call operator several times in similar settings: you can think of it as a warm up.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"By default, all the preparation functions return nothing. We do not make any guarantees on their implementation for each backend, or on the performance gains that can be expected.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"warning: Warning\nWe haven't fully figured out what must happen when an extras object is prepared for a specific operator but then given to a lower-level one (i.e. prepare it for jacobian but then give it to pushforward inside jacobian).","category":"page"},{"location":"overview/#Multiple-inputs/outputs","page":"Overview","title":"Multiple inputs/outputs","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Restricting the API to one input and one output has many coding advantages, but it is not very flexible. If you need more than that, use ComponentArrays.jl to wrap several objects inside a single ComponentVector.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"CurrentModule = Main\nCollapsedDocStrings = true","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"using ADTypes, DifferentiationInterface\nusing DifferentiationInterfaceTest: backend_string\nimport Markdown\nimport Enzyme, FastDifferentiation, FiniteDiff, FiniteDifferences, ForwardDiff, PolyesterForwardDiff, ReverseDiff, Tracker, Zygote\n\nfunction all_backends()\n    return [\n        AutoDiffractor(),\n        AutoEnzyme(Enzyme.Forward),\n        AutoEnzyme(Enzyme.Reverse),\n        AutoFastDifferentiation(),\n        AutoFiniteDiff(),\n        AutoFiniteDifferences(FiniteDifferences.central_fdm(3, 1)),\n        AutoForwardDiff(),\n        AutoPolyesterForwardDiff(; chunksize=2),\n        AutoReverseDiff(),\n        AutoTapir(),\n        AutoTracker(),\n        AutoZygote(),\n    ]\nend\n\nfunction all_backends_without_enzyme()\n    return filter(all_backends()) do b\n        !isa(b, AutoEnzyme)\n    end\nend","category":"page"},{"location":"backends/#Backends","page":"Backends","title":"Backends","text":"","category":"section"},{"location":"backends/#Types","page":"Backends","title":"Types","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"We support (and re-export) most backend choices from ADTypes.jl, and we provide a few more of our own.","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"warning: Warning\nOnly the backends listed below are supported by DifferentiationInterface.jl, even though ADTypes.jl defines more.","category":"page"},{"location":"backends/#Dense","page":"Backends","title":"Dense","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"AutoChainRules\nAutoDiffractor\nAutoEnzyme\nAutoFastDifferentiation\nAutoForwardDiff\nAutoForwardDiff()\nAutoFiniteDiff\nAutoFiniteDifferences\nAutoPolyesterForwardDiff\nAutoPolyesterForwardDiff()\nAutoReverseDiff\nAutoTapir\nAutoTracker\nAutoZygote","category":"page"},{"location":"backends/#ADTypes.AutoChainRules","page":"Backends","title":"ADTypes.AutoChainRules","text":"AutoChainRules{RC}\n\nChooses any AD library based on ChainRulesCore.jl, given an appropriate RuleConfig object.\n\nFields\n\nruleconfig::RC\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoDiffractor","page":"Backends","title":"ADTypes.AutoDiffractor","text":"AutoDiffractor\n\nChooses Diffractor.jl.\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoEnzyme","page":"Backends","title":"ADTypes.AutoEnzyme","text":"AutoEnzyme(Enzyme.Forward)\nAutoEnzyme(Enzyme.Reverse)\n\nConstruct a forward or reverse mode AutoEnzyme backend.\n\n\n\n\n\nAutoEnzyme{M}\n\nChooses Enzyme.jl.\n\nFields\n\nmode::M = nothing\n\n\n\n\n\n","category":"type"},{"location":"backends/#DifferentiationInterface.AutoFastDifferentiation","page":"Backends","title":"DifferentiationInterface.AutoFastDifferentiation","text":"AutoFastDifferentiation\n\nChooses FastDifferentiation.jl.\n\ndanger: Danger\nThis backend is experimental, use at your own risk.\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoForwardDiff","page":"Backends","title":"ADTypes.AutoForwardDiff","text":"AutoForwardDiff{chunksize,T}\n\nChooses ForwardDiff.jl.\n\nFields\n\ntag::T\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoForwardDiff-Tuple{}","page":"Backends","title":"ADTypes.AutoForwardDiff","text":"AutoForwardDiff(; chunksize = nothing, tag = nothing)\n\nConstructor.\n\n\n\n\n\n","category":"method"},{"location":"backends/#ADTypes.AutoFiniteDiff","page":"Backends","title":"ADTypes.AutoFiniteDiff","text":"AutoFiniteDiff{T1,T2,T3}\n\nChooses FiniteDiff.jl.\n\nFields\n\nfdtype::T1 = Val(:forward)\nfdjtype::T2 = fdtype\nfdhtype::T3 = Val(:hcentral)\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoFiniteDifferences","page":"Backends","title":"ADTypes.AutoFiniteDifferences","text":"AutoFiniteDifferences{T}\n\nChooses FiniteDifferences.jl.\n\nFields\n\nfdm::T = nothing\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoPolyesterForwardDiff","page":"Backends","title":"ADTypes.AutoPolyesterForwardDiff","text":"AutoPolyesterForwardDiff{chunksize}\n\nChooses PolyesterForwardDiff.jl.\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoPolyesterForwardDiff-Tuple{}","page":"Backends","title":"ADTypes.AutoPolyesterForwardDiff","text":"AutoPolyesterForwardDiff(; chunksize = nothing)\n\nConstructor.\n\n\n\n\n\n","category":"method"},{"location":"backends/#ADTypes.AutoReverseDiff","page":"Backends","title":"ADTypes.AutoReverseDiff","text":"AutoReverseDiff\n\nChooses ReverseDiff.jl.\n\nFields\n\ncompile::Bool = false\n\n\n\n\n\n","category":"type"},{"location":"backends/#DifferentiationInterface.AutoTapir","page":"Backends","title":"DifferentiationInterface.AutoTapir","text":"AutoTapir\n\nChooses Tapir.jl.\n\ndanger: Danger\nThis backend is experimental, use at your own risk.\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoTracker","page":"Backends","title":"ADTypes.AutoTracker","text":"AutoTracker\n\nChooses Tracker.jl.\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoZygote","page":"Backends","title":"ADTypes.AutoZygote","text":"AutoZygote\n\nChooses Zygote.jl.\n\n\n\n\n\n","category":"type"},{"location":"backends/#Sparse","page":"Backends","title":"Sparse","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"danger: Danger\nSparsity support is still experimental, use at your own risk.","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"AutoSparseFastDifferentiation\nAutoSparseFiniteDiff\nAutoSparseForwardDiff\nAutoSparseForwardDiff()\nAutoSparsePolyesterForwardDiff\nAutoSparseReverseDiff\nAutoSparseZygote","category":"page"},{"location":"backends/#DifferentiationInterface.AutoSparseFastDifferentiation","page":"Backends","title":"DifferentiationInterface.AutoSparseFastDifferentiation","text":"AutoSparseFastDifferentiation\n\nChooses FastDifferentiation.jl leveraging sparsity.\n\ndanger: Danger\nThis backend is experimental, use at your own risk.\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoSparseFiniteDiff","page":"Backends","title":"ADTypes.AutoSparseFiniteDiff","text":"AutoSparseFiniteDiff\n\nChooses FiniteDiff.jl while exploiting sparsity.\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoSparseForwardDiff","page":"Backends","title":"ADTypes.AutoSparseForwardDiff","text":"AutoSparseForwardDiff{chunksize,T}\n\nChooses ForwardDiff.jl while exploiting sparsity.\n\nFields\n\ntag::T\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoSparseForwardDiff-Tuple{}","page":"Backends","title":"ADTypes.AutoSparseForwardDiff","text":"AutoSparseForwardDiff(; chunksize = nothing, tag = nothing)\n\nConstructor.\n\n\n\n\n\n","category":"method"},{"location":"backends/#ADTypes.AutoSparsePolyesterForwardDiff","page":"Backends","title":"ADTypes.AutoSparsePolyesterForwardDiff","text":"AutoSparsePolyesterForwardDiff{chunksize}\n\nChooses PolyesterForwardDiff.jl while exploiting sparsity.\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoSparseReverseDiff","page":"Backends","title":"ADTypes.AutoSparseReverseDiff","text":"AutoSparseReverseDiff\n\nChooses ReverseDiff.jl while exploiting sparsity.\n\nFields\n\ncompile::Bool = false\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoSparseZygote","page":"Backends","title":"ADTypes.AutoSparseZygote","text":"AutoSparseZygote\n\nChooses Zygote.jl while exploiting sparsity.\n\n\n\n\n\n","category":"type"},{"location":"backends/#Availability","page":"Backends","title":"Availability","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"You can use check_available to verify whether a given backend is loaded, like we did below:","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"header = \"| backend | available |\"  # hide\nsubheader = \"|---|---|\"  # hide\nrows = map(all_backends()) do backend  # hide\n    \"| `$(backend_string(backend))` | $(check_available(backend) ? '✅' : '❌') |\"  # hide\nend  # hide\nMarkdown.parse(join(vcat(header, subheader, rows...), \"\\n\"))  # hide","category":"page"},{"location":"backends/#Mutation-support","page":"Backends","title":"Mutation support","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"All backends are compatible with allocating functions f(x) = y. Only some are compatible with mutating functions f!(y, x) = nothing. You can use check_mutation to check that feature, like we did below:","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"header = \"| backend | mutation |\"  # hide\nsubheader = \"|---|---|\"  # hide\nrows = map(all_backends()) do backend  # hide\n    \"| `$(backend_string(backend))` | $(check_mutation(backend) ? '✅' : '❌') |\"  # hide\nend  # hide\nMarkdown.parse(join(vcat(header, subheader, rows...), \"\\n\"))  # hide","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"https://github.com/gdalle/DifferentiationInterface.jl/blob/main/README.md\"","category":"page"},{"location":"#DifferentiationInterface","page":"Home","title":"DifferentiationInterface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"An interface to various automatic differentiation (AD) backends in Julia.","category":"page"},{"location":"#Goal","page":"Home","title":"Goal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a backend-agnostic syntax to differentiate functions of the following types:","category":"page"},{"location":"","page":"Home","title":"Home","text":"allocating: f(x) = y\nmutating: f!(y, x) = nothing","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First and second order operators\nIn-place and out-of-place differentiation\nPreparation mechanism (e.g. to create a config or tape)\nCross-backend testing and benchmarking utilities\nThorough validation on standard inputs and outputs (scalars, vectors, matrices)","category":"page"},{"location":"#Compatibility","page":"Home","title":"Compatibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We support most of the backends defined by ADTypes.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"backend object\nChainRulesCore.jl AutoChainRules(ruleconfig)\nDiffractor.jl AutoDiffractor()\nEnzyme.jl AutoEnzyme(Enzyme.Forward) or AutoEnzyme(Enzyme.Reverse)\nFiniteDiff.jl AutoFiniteDiff()\nFiniteDifferences.jl AutoFiniteDifferences(fdm)\nForwardDiff.jl AutoForwardDiff()\nPolyesterForwardDiff.jl AutoPolyesterForwardDiff(; chunksize)\nReverseDiff.jl AutoReverseDiff()\nTracker.jl AutoTracker()\nZygote.jl AutoZygote()","category":"page"},{"location":"","page":"Home","title":"Home","text":"We also support additional (experimental) backends:","category":"page"},{"location":"","page":"Home","title":"Home","text":"backend object\nFastDifferentiation.jl AutoFastDifferentiation()\nTapir.jl AutoTapir()","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> import ForwardDiff\n\njulia> using DifferentiationInterface\n\njulia> backend = AutoForwardDiff();\n\njulia> f(x) = sum(abs2, x);\n\njulia> value_and_gradient(f, backend, [1., 2., 3.])\n(14.0, [2.0, 4.0, 6.0])","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AbstractDifferentiation.jl is the original inspiration for DifferentiationInterface.jl.\nAutoDiffOperators.jl is an attempt to bridge ADTypes.jl with AbstractDifferentiation.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"extensions/#Package-extensions","page":"Package extensions","title":"Package extensions","text":"","category":"section"},{"location":"extensions/","page":"Package extensions","title":"Package extensions","text":"CurrentModule = DifferentiationInterface","category":"page"},{"location":"extensions/","page":"Package extensions","title":"Package extensions","text":"Backend-specific extension content is not part of the public API. If any docstrings are present in an extension, they will appear below.","category":"page"},{"location":"extensions/","page":"Package extensions","title":"Package extensions","text":"Modules = [\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceChainRulesCoreExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceDiffractorExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceEnzymeExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceFastDifferentiationExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceFiniteDiffExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceFiniteDifferencesExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceForwardDiffExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfacePolyesterForwardDiffExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceReverseDiffExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceSparseDiffToolsExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceTapirExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceTrackerExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceZygoteExt)\n]\nFilter = t -> !(t isa Type && t <: ADTypes.AbstractADType)","category":"page"},{"location":"extensions/","page":"Package extensions","title":"Package extensions","text":"","category":"page"}]
}
